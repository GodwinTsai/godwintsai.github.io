{"title":"脚本解析photoshop文本属性","uid":"5992dcd2bf88f595edc9caf556b4762c","slug":"脚本解析photoshop文本属性","date":"2017-09-23T10:35:11.000Z","updated":"2022-07-16T12:23:29.000Z","comments":true,"path":"api/articles/脚本解析photoshop文本属性.json","keywords":null,"cover":[],"content":"<span id=\"more\"></span>\n\n<p>尊重原创，转载请在文首注明出处：<a href=\"http://blog.csdn.net/cai612781/article/details/78072531\">http://blog.csdn.net/cai612781/article/details/78072531</a></p>\n<p>在做unity项目中，用到了psd2ngui插件来把psd直接导出成prefab，psd2ngui的原理就是解析psd中图层的命名来生成组件。用的还是最早的版本，插件中导出的文本只有一个文本内容，其余属性例如颜色、字号、描边、投影都得另外设置，很麻烦，新版不知有没这功能，一直没有继续研究。于是当时就有了这么个想法，写个ps脚本，解析文本的属性并命名，再扩展插件来实现导出ui后不用额外修改文本属性。这也是很早很早之前做的，现在来总结下。</p>\n<h2 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h2><p>ps支持几种脚本语言，Mac平台有AppleScript,Windows平台有VBScript，以及两个平台都支持的JavaScript。我用的就是Js语言，后缀是jsx。</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>可以使用任何文本编辑来写代码，这里推荐Adobe的IDE，叫Adobe ExtendScript Tookit，支持断点调试，还可以通过Data Browser窗口查看对象的属性和方法。</p>\n<p><img src=\"https://img-blog.csdn.net/20171105130835946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">  </p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>ps script一种方式是通过文本对象模型DOM（Document Object Model）来访问和修改psd中的对象的属性，直观而方便，但不能实现所有的ps操作。 </p>\n<p>ps dom类结构图：</p>\n<p><img src=\"https://img-blog.csdn.net/20171105144858740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">  </p>\n<p>另一种方式是通过动作代理(ActionManager)的方式，可以实现比DOM更多的操作，但貌似不支持AppleScript。</p>\n<p>动作代理主要类有ActionDescriptor，ActionReference，ActionList。</p>\n<p>ActionDescriptor相当于一个存储属性和值的字典,</p>\n<p>ActionList是一个存储相同属性的值的数组，</p>\n<p>ActionReference存储一个action的引用，</p>\n<p>举个栗子：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function emboss(inAngle, inHeight, inAmount)\n&#123;\n\tvar keyAngleID &#x3D; charIDToTypeID(&quot;Angl&quot;);\n\tvar keyHeightID &#x3D; charIDToTypeID(&quot;Hght&quot;);\n\tvar keyAmountID &#x3D; charIDToTypeID(&quot;Amnt&quot;);\n\tvar eventEmbossID &#x3D; charIDToTypeID(&quot;Embs&quot;);\n\t\n\tvar filterDescriptor &#x3D; new ActionDescriptor();\n\tfilterDescriptor.putInteger(keyAngleID, inAngle);\n\tfilterDescriptor.putInteger(keyHeightID, inHeight);\n\tfilterDescriptor.putInteger(keyAmountID, inAmount);\n\t\n\texecuteAction(eventEmbossID, filterDescriptor);\n&#125;\n\nemboss(120, 10, 100);</code></pre>\n\n<p>运行该脚本，会给选中图层添加一个浮雕滤镜</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>ActionManager看起来比DOM复杂繁琐，好在Adobe有个监听Action的插件，下载地址：</p>\n<p>Windows： <a href=\"http://download.adobe.com/pub/adobe/photoshop/win/13.x/Win_Scripting_Plug-In.zip\">ScriptingListenerPlugInForWindow</a> </p>\n<p>Mac：<a href=\"http://download.adobe.com/pub/adobe/photoshop/mac/13.x/Scripting_Plug_In_Release.dmg\">ScriptingListenerPlugInForMac </a></p>\n<p>下载解压后将ScriptListener.8li拷贝到Adobe Photoshop&#x2F;Plug-ins&#x2F;目录下即可。</p>\n<p>重开ps，操作将会被记录在桌面的ScriptingListenerJS.log和ScriptingListenerVB.log中</p>\n<p>切记不用时把该插件移除，需要时再复制到Plug-ins目录下，以免撑爆磁盘以及影响ps操作性能。或者使用下载的压缩包里带有两个开关插件的脚本。</p>\n<p><img src=\"https://img-blog.csdn.net/20171105133542960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p>\n<p>上图记录了我打开一张图片，选中它，改变颜色三个步骤的脚步。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h4 id=\"遍历所有文本图层\"><a href=\"#遍历所有文本图层\" class=\"headerlink\" title=\"##遍历所有文本图层\"></a>##遍历所有文本图层</h4><p>ps script中跟图层相关的对象有LayerSet(组)，ArtLayer(图层)，Layer(包括组和图层)。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function getTextLayers(layers)\n&#123;\n\tfor(var i &#x3D; 0, len &#x3D; layers.length; i &lt; len; i++)\n\t&#123;\n\t\tif(layers[i].typename &#x3D;&#x3D; &quot;LayerSet&quot;)\n\t\t&#123;\n\t\t\tgetTextLayers(layers[i].layers)\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tif(layers[i].kind &#x3D;&#x3D; LayerKind.TEXT)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;得到文本图层\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\ngetTextLayers(app.activeDocument.layers);</code></pre>\n\n<h4 id=\"文本字号和颜色\"><a href=\"#文本字号和颜色\" class=\"headerlink\" title=\"##文本字号和颜色\"></a>##文本字号和颜色</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var text &#x3D; layer.textItem;&#x2F;&#x2F;layer即上文得到的layers[i]</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var color &#x3D; text.color.rgb[&quot;hexValue&quot;];\nvar size &#x3D; text.size.value;</code></pre>\n\n<p>下面代码是怎么从layer获得ActionDescriptor， 需要先将layer设置为目标图层：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">app.activeDocument.activeLayer &#x3D; layer;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function char2Type(charId)\n&#123;\n\treturn app.charIDToTypeID(charId);\n&#125;\n\nfunction getActiveLayerDescriptor()\n&#123;\n\tvar ref &#x3D; new ActionReference();\n\tref.putEnumerated(char2Type(&quot;Lyr &quot;), char2Type(&quot;Ordn&quot;), char2Type(&quot;Trgt&quot;));\n\treturn executeActionGet(ref);\n&#125;\n\nvar layerDesc &#x3D; getActiveLayerDescriptor();</code></pre>\n\n<h4 id=\"描边-x2F-投影颜色\"><a href=\"#描边-x2F-投影颜色\" class=\"headerlink\" title=\"##描边&#x2F;投影颜色\"></a>##描边&#x2F;投影颜色</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function getOutline(layerDesc)&#x2F;&#x2F;layerDesc参数即上文通过layer获得的ActionDescriptor类型对象\n&#123;\n\tvar isEffectVisible &#x3D; layerDesc.getVal(&quot;layerFXVisible&quot;);&#x2F;&#x2F;判断图层是否有可见效果\n\tif(!isEffectVisible)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar lfxDesc &#x3D; layerDesc.getVal(&quot;layerEffects&quot;);&#x2F;&#x2F;获得图层效果属性\n\tvar dsDesc &#x3D; lfxDesc ? lfxDesc.getVal(&quot;frameFX&quot;) : null;&#x2F;&#x2F;获得图层描边属性</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\t&#x2F;&#x2F;var dsDesc &#x3D; lfxDesc ? lfxDesc.getVal(&quot;dropShadow&quot;) : null;&#x2F;&#x2F;获得图层投影属性\n\n\tif(dsDesc &#x3D;&#x3D; null)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar enable &#x3D; dsDesc.getVal(&quot;enabled&quot;);&#x2F;&#x2F;判断描边&#x2F;投影是否启用\n\tif(!enable)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar rgbTxt &#x3D; descToColorList(dsDesc, &quot;color&quot;);&#x2F;&#x2F;获得图层描边&#x2F;投影颜色\n\treturn changeToHex(rgbTxt);&#x2F;&#x2F;转换成16进制\n&#125;</code></pre>\n\n<h4 id=\"渐变颜色\"><a href=\"#渐变颜色\" class=\"headerlink\" title=\"##渐变颜色\"></a>##渐变颜色</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function getGradientFill(layerDesc)\n&#123;\n\tvar isEffectVisible &#x3D; layerDesc.getVal(&quot;layerFXVisible&quot;);\n\tif(!isEffectVisible)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar lfxDesc &#x3D; layerDesc.getVal(&quot;layerEffects&quot;);\n\tvar dsDesc &#x3D; lfxDesc ? lfxDesc.getVal(&quot;gradientFill&quot;) : null;\n\tif(dsDesc &#x3D;&#x3D; null)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar enable &#x3D; dsDesc.getVal(&quot;enabled&quot;);\n\tif(!enable)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\t\n\tvar graDesc &#x3D; dsDesc.getVal(&quot;gradient&quot;);\n\t\n\tvar colorList &#x3D; graDesc.getVal(&quot;colors&quot;, false);&#x2F;&#x2F;ps中可以有多个渐变颜色，unity中一般两个\n\tvar result &#x3D; &quot;&quot;;\n\tfor(s in colorList)\n\t&#123;\n\t\tvar rgbTxt &#x3D; descToColorList(colorList[s], &quot;color&quot;);\n\t\tresult +&#x3D; changeToHex(rgbTxt) + &quot;,&quot;;\n\t&#125;\n\tresult &#x3D; result.substr(0, result.length - 1);\n\treturn result;\n&#125;</code></pre>\n\n<h4 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"##调用方法\"></a>##调用方法</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;&#x2F;desc.getVal( keyList );方法的实现，获得desc的属性keyList对应的值</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">ActionDescriptor.prototype.getVal &#x3D; function(keyList, firstListItemOnly)\n&#123;\n\tif (typeof(keyList) &#x3D;&#x3D; &#39;string&#39;)\n\t&#123;\n\t\tkeyList &#x3D; keyList.split(&#39;.&#39;);\n\t&#125;\n\t\t\n\tif (typeof(firstListItemOnly) &#x3D;&#x3D; &quot;undefined&quot;)\n\t&#123;\n\t\tfirstListItemOnly &#x3D; true;\n\t&#125;\n\t\n\tif (keyList.length &#x3D;&#x3D; 0)\n\t&#123;\n\t\treturn this;\n\t&#125;\n\t\n\tkeyStr &#x3D; keyList.shift();\n\tkeyID &#x3D; makeID(keyStr);\n\t\n\tif (this.hasKey(keyID))\n\t&#123;\n\t\tswitch (this.getType(keyID))\n\t\t&#123;\n\t\t\tcase DescValueType.OBJECTTYPE:&#x2F;&#x2F;属性类型为Object\n\t\t\t&#123;\n\t\t\t\treturn this.getObjectValue(keyID).getVal(keyList, firstListItemOnly);\n\t\t\t&#125;\n\t\t\tcase DescValueType.LISTTYPE:&#x2F;&#x2F;属性类型为列表\n\t\t\t&#123;\n\t\t\t\tvar list &#x3D; this.getList(keyID); \n\t\t\t\treturn list.getVal(keyList, firstListItemOnly);\n\t\t\t&#125;\t\n\t\t\tdefault: \n\t\t\t&#123;\n\t\t\t\treturn this.getFlatType(keyID);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\t\n\telse\n\t&#123;\n\t\treturn null;\n\t&#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;&#x2F;将charID或stringID转换成TypeID</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">charID、string相当于底层定义的属性枚举</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function makeID(keyStr)\n&#123;\n\tif (keyStr[0] &#x3D;&#x3D; &quot;&#39;&quot;)\n\t&#123;\n\t\treturn app.charIDToTypeID(keyStr);\n\t&#125;\n\telse\n\t&#123;\n\t\treturn app.stringIDToTypeID(keyStr);\n\t&#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;&#x2F;根据不同类型获得最终的值</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function getFlatType(desc, ID)\n&#123;\n\tswitch (desc.getType(ID))\n\t&#123;\n\t\tcase DescValueType.BOOLEANTYPE:\t\treturn desc.getBoolean(ID);\n\t\tcase DescValueType.STRINGTYPE:\t\treturn desc.getString(ID);\n\t\tcase DescValueType.INTEGERTYPE:\t\treturn desc.getInteger(ID);\n\t\tcase DescValueType.DOUBLETYPE:\t\treturn desc.getDouble(ID);\n\t\tcase DescValueType.UNITDOUBLE:\t\treturn getPSUnitValue(desc, ID);\n\t\tcase DescValueType.ENUMERATEDTYPE: \treturn typeIDToStringID(desc.getEnumerationValue(ID));\n\t\tcase DescValueType.REFERENCETYPE: \treturn getReference(desc.getReference(ID));\n\t\tdefault: \t\t\t\treturn desc.getType(ID).toString();\n\t&#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;&#x2F;获得颜色rgb值</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function descToColorList(colorDesc, colorPath)\n&#123;\n\tvar i, rgb &#x3D; [&quot;&#39;Rd  &#39;&quot;, &quot;&#39;Grn &#39;&quot;,&quot;&#39;Bl  &#39;&quot;];\n\tvar rgbTxt &#x3D; [];\n\t\n\tcolorDesc &#x3D; colorDesc.getVal(colorPath);\n\tif (!colorDesc)\n\t&#123;\n\t\treturn null;\n\t&#125;\n\n\tfor (i in rgb)\n\t&#123;\n\t\trgbTxt.push( roundColor(colorDesc.getVal(rgb[i])));\n\t&#125;\n\treturn rgbTxt;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;&#x2F;转换成16进制颜色值</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function changeToHex(rgbTxt)\n&#123;\n\tvar value &#x3D; &quot;&quot;;\n\tfor(var i &#x3D; 0, len &#x3D; rgbTxt.length; i &lt; len; i++)\n\t&#123;\n\t\tvar string &#x3D; rgbTxt[i].toString(16);\n\t\tif(string.length &lt; 2)\n\t\t&#123;\n\t\t\tstring &#x3D; &quot;0&quot; + string;\n\t\t&#125;\n\t\tvalue +&#x3D; string;\n\t&#125;\n\treturn value;\n&#125;</code></pre>\n\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>将代码保存为.jsx后缀文件，放在ps安装目录\\Presets\\Scripts\\下</p>\n<p>运行路径：ps中文件-脚本-.jsx</p>\n<p>运行结果图</p>\n<p>运行前：</p>\n<p><img src=\"https://img-blog.csdn.net/20171105141904470?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">  </p>\n<p>运行后：</p>\n<p><img src=\"https://img-blog.csdn.net/20171105141923655?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">  </p>\n<p>以上就是ps脚本解析psd中文本图层的描边、投影、渐变等属性的主要代码，文本还有许多其它属性，不过unity项目中基本不用。</p>\n<p>完整的脚本在github:<a href=\"https://github.com/503913873/PhotoshopTextParse\">https://github.com/503913873/PhotoshopTextParse</a></p>\n<p>该脚本写得比较早，脚本中一些方法写得比较繁琐，例如遍历图层是用ActionManager方式，没有文中采用DOM方式来得简洁易懂，</p>\n<p>github里第二个脚本就是文中的方式。</p>\n<p>貌似ps不同版本的代码也有些差异，该脚本在cs5、cs6中都运行过，基本都可以用，小概率会出现解析的文本字号带小数。</p>\n<p>更详细的语法可以在Adobe官网上查看：<a href=\"http://www.adobe.com/devnet/photoshop/scripting.html\">http://www.adobe.com/devnet/photoshop/scripting.html</a></p>\n<p>文笔不好，又是第一次写，写了好多天，ps script研究得也不深，基本是需要什么功能才去搜索，欢迎大家一起讨论学习。</p>\n","feature":true,"text":" 尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78072531 在做unity项目中，用到了psd2ngui插件来把psd直接导出成prefab，psd2ngui的原理就是解析psd中图层的命名来生...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"PhotoShop","slug":"PhotoShop","count":2,"path":"api/categories/PhotoShop.json"}],"tags":[{"name":"photoshop script ps script actionmanager","slug":"photoshop-script-ps-script-actionmanager","count":1,"path":"api/tags/photoshop-script-ps-script-actionmanager.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">语言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">插件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E6%96%87%E6%9C%AC%E5%9B%BE%E5%B1%82\"><span class=\"toc-text\">##遍历所有文本图层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%9C%AC%E5%AD%97%E5%8F%B7%E5%92%8C%E9%A2%9C%E8%89%B2\"><span class=\"toc-text\">##文本字号和颜色</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%8F%E8%BE%B9-x2F-%E6%8A%95%E5%BD%B1%E9%A2%9C%E8%89%B2\"><span class=\"toc-text\">##描边&#x2F;投影颜色</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B8%90%E5%8F%98%E9%A2%9C%E8%89%B2\"><span class=\"toc-text\">##渐变颜色</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">##调用方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">运行</span></a></li></ol>","author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Skill&Buff Editor","uid":"9445c1590d18cd4588eaa614d62d2feb","slug":"Skill&Buff Editor","date":"2020-04-02T02:57:25.000Z","updated":"2022-07-16T11:30:57.000Z","comments":true,"path":"api/articles/Skill&Buff Editor.json","keywords":null,"cover":[],"text":" 之前项目做的一个moba的skill&amp;buff编辑器，采用winform实现，独立于Unity。 主编辑窗口（图中左上角），通过c# Attribute，反射技能逻辑的字段，采用节点和连线编辑，独立于具体的技能逻辑。 节点的属性编辑（图中右上角）通过扩展winform的...","link":"","photos":[],"count_time":{"symbolsCount":304,"symbolsTime":"1 mins."},"categories":[{"name":"C#","slug":"C","count":4,"path":"api/categories/C.json"}],"tags":[{"name":"Unity","slug":"Unity","count":1,"path":"api/tags/Unity.json"}],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Unity世界坐标局部坐标转换","uid":"3ec350ecf5fdab2807ec97539f38afce","slug":"Unity世界坐标局部坐标转换","date":"2020-04-01T12:23:08.000Z","updated":"2022-07-16T11:30:57.000Z","comments":true,"path":"api/articles/Unity世界坐标局部坐标转换.json","keywords":null,"cover":null,"text":" world pos -&gt; ui local pos世界坐标转UI局部坐标比较常用，也比较简单。 Vector3 worldPosition &#x3D; _3dTransform.position; Vector3 screenPosition &#x3D; _3dCam...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"Unity","slug":"Unity","count":5,"path":"api/categories/Unity.json"}],"tags":[],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}