{"title":"Unity&NGUI渲染层级","uid":"77e0ad570f11e18afc3feb02810d2091","slug":"Unity&NGUI渲染层级","date":"2017-11-08T06:00:02.000Z","updated":"2022-07-16T11:30:57.118Z","comments":true,"path":"api/articles/Unity&NGUI渲染层级.json","keywords":null,"cover":[],"content":"<span id=\"more\"></span>\n\n<p>尊重原创，转载请在文首注明出处：<a href=\"http://blog.csdn.net/cai612781/article/details/78477944\">http://blog.csdn.net/cai612781/article/details/78477944</a>  </p>\n<p>项目中经常遇到层级的显示问题，来总结下。</p>\n<h1 id=\"一，Unity\"><a href=\"#一，Unity\" class=\"headerlink\" title=\"一，Unity\"></a>一，Unity</h1><p>按优先级从高到低排列：</p>\n<h2 id=\"1，Camera-depth\"><a href=\"#1，Camera-depth\" class=\"headerlink\" title=\"1，Camera.depth\"></a>1，Camera.depth</h2><p>depth小的先渲染。</p>\n<p><img src=\"https://img-blog.csdn.net/20171108235141309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">  </p>\n<h2 id=\"2，Renderer-sortingLayerID\"><a href=\"#2，Renderer-sortingLayerID\" class=\"headerlink\" title=\"2，Renderer.sortingLayerID\"></a>2，Renderer.sortingLayerID</h2><p>sortingLayerID为基类Renderer的属性，sortingLayerID小的先渲染。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><p>3，Renderer.sortingOrder</p>\n<p>sortingOrder同为基类Renderer的属性，sortingOrder小的先渲染。</p>\n<p>sortingLayerID和sortingOrder虽然是基类Renderer的属性，但只适用于Unity2d的排序，因此我们在面板中可以看到只有显示图片的SpriteRenderer和显示粒子的</p>\n<p>ParticleSystemRenderer有这两个属性。</p>\n<p><img src=\"https://img-blog.csdn.net/20171108235453765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"><img src=\"https://img-blog.csdn.net/20171108235556426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">  </p>\n<h2 id=\"4，Material-renderQueue\"><a href=\"#4，Material-renderQueue\" class=\"headerlink\" title=\"4，Material.renderQueue\"></a>4，Material.renderQueue</h2><p>该属性对应的是Shader的renderQueue，renderQueue的范围必须是[0,5000]，数值小的先渲染。Shader中使用SubShader的Queue标签来设定模型属于哪个渲染队列。</p>\n<p>Unity内置了几个渲染队列的枚举：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public enum RenderQueue\n&#123;\n        Background &#x3D; 1000,&#x2F;&#x2F;最先渲染，通常用来绘制背景\n        Geometry &#x3D; 2000,&#x2F;&#x2F;不透明物体的渲染\n        AlphaTest &#x3D; 2450, &#x2F;&#x2F; 需要透明度测试的物体，在不透明物体渲染后再渲染会更高效\n        GeometryLast &#x3D; 2500, &#x2F;&#x2F; 分界线，[0,2500]为不透明物体，[2501,5000]为半透明物体\n        Transparent &#x3D; 3000,&#x2F;&#x2F;半透明物体的渲染，任何使用了透明度混合（例如关闭了深度写入）的物体都用得用该队列\n        Overlay &#x3D; 4000,&#x2F;&#x2F;用于叠加效果\n&#125;</code></pre>\n\n<p>上述排序是在Shader关闭了深度写入（ZWrite Off）的情况下，当开启了深度写入时，物体的空间位置（transform.position.z）会影响层级，z值小的在前面。</p>\n<p>另外，Unity菜单Edit-&gt;Project Settings-&gt;Tags中的Layers,只是一个逻辑的分层，用于Camera的Culling Mask来设置相机渲染哪个Layer的物体，辅助Camera.depth来管理层级。</p>\n<h1 id=\"二，NGUI\"><a href=\"#二，NGUI\" class=\"headerlink\" title=\"二，NGUI\"></a>二，NGUI</h1><p>按优先级从高到低排列：  </p>\n<h2 id=\"1，UIPanel-sortingOrder\"><a href=\"#1，UIPanel-sortingOrder\" class=\"headerlink\" title=\"1，UIPanel.sortingOrder\"></a>1，UIPanel.sortingOrder</h2><p>通过源码可以看到UIPanel.sortingOrder更改的就是上文中Renderer.sortingOrder。</p>\n<h2 id=\"2，UIPanel-depth\"><a href=\"#2，UIPanel-depth\" class=\"headerlink\" title=\"2，UIPanel.depth\"></a>2，UIPanel.depth</h2><p>depth小的先渲染</p>\n<h2 id=\"3，UIWidget-depth\"><a href=\"#3，UIWidget-depth\" class=\"headerlink\" title=\"3，UIWidget.depth\"></a>3，UIWidget.depth</h2><p>depth小的先渲染，NGUI根据UIWidget.depth的排序合并drawcall（因此尽量将相同材质的图集在depth上排在一起可以减少UI上的drawcall）。</p>\n<p>UIPanel面板还有个Render Q属性，用来设置该面板的renderQueue的起始值，所有面板总的起始值默认为3000。该属性有三种选项，分别是</p>\n<p>Automatic，StartAt，Explicit，后两者可自定义renderQueue的起始值。</p>\n<p><img src=\"https://img-blog.csdn.net/20171108235959691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FpNjEyNzgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">  </p>\n<p>当Render Q默认为Automatic时，根据UIPanel.depth的排序对drawcall的材质的renderqueue进行排序。</p>\n<p>当Render Q默认为StartAt或Explicit时，UIPanel.depth则不起作用，根据自定义的值对drawcall的材质的renderqueue进行排序。</p>\n<p>NGUI所用的shader都是关闭了深度写入的，因此z值不影响层级。所以NGUI本质还是通过Unity的sortingOrder和renderQueue来管理层级。</p>\n<h1 id=\"三，NGUI与模型或特效的夹层问题\"><a href=\"#三，NGUI与模型或特效的夹层问题\" class=\"headerlink\" title=\"三，NGUI与模型或特效的夹层问题\"></a>三，NGUI与模型或特效的夹层问题</h1><p>我们在处理模型或特效显示在两个UI之间的层级显示问题，有两种方式：</p>\n<p>1，利用Camera.depth属性，将界面A，模型或特效，界面B分别放在三个Layer，用三个depth递增的相机来渲染。（该方式不推荐，因为一个界面上可能会打开新的界面，以及两个界面的相对层次不是固定的，这样会导致相机不断增加，层次管理混乱）</p>\n<p>2，利用renderQueue属性，给两个UIPanel之间留下一定范围的renderQueue数值，将模型或特效的renderQueue设置在这个范围内。（推荐该方式）</p>\n<p>代码如下：</p>\n<p>第一步，新增renderQueue控制脚本：RenderQueueContro.cs</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">using System.Collections.Generic;\nusing UnityEngine;\n\npublic class RenderQueueControl : MonoBehaviour\n&#123;\n\tprivate UIPanel _panel;\n\t\n\tprivate int _rq;\n\tprivate List&lt;Material&gt; _materialList &#x3D; new List&lt;Material&gt;();\n\tprivate int i, len;\n\t\n\tvoid Start()\n\t&#123;\n\t&#125;\n\t\n\tpublic void Init()\n\t&#123;\n\t\t_panel &#x3D; NGUITools.FindInParents&lt;UIPanel&gt;(gameObject);\n\t\tUIPanel.AddModelRQ(this);\n\t\tInitMaterials();\n\t&#125;\n\t\n\tprivate void InitMaterials()\n\t&#123;\n\t\t_materialList.Clear();\n\t\tRenderer[] ren &#x3D; GetComponentsInChildren&lt;Renderer&gt;();\n\t\tif(ren !&#x3D; null)\n\t\t&#123;\n\t\t\tfor(i &#x3D; 0, len &#x3D; ren.Length; i &lt; len; i++)\n\t\t\t&#123;\n\t\t\t\t_materialList.AddRange(ren[i].materials);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\tpublic void UpdateRQ()\n\t&#123;\n\t\tif(_panel !&#x3D; null &amp;&amp; _panel.drawCalls.Count &gt; 0)\n\t\t&#123;\n\t\t\t_rq &#x3D; _panel.drawCalls[_panel.drawCalls.Count - 1].renderQueue + 1;\n\t\t\tfor(i &#x3D; 0, len &#x3D; _materialList; i &lt; len; i++)\n\t\t\t&#123;\n\t\t\t\tif(_materialList[i].renderQueue !&#x3D; _rq)\n\t\t\t\t&#123;\n\t\t\t\t\t_materialList[i].renderQueue &#x3D; _rq;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\tvoid OnDestroy()\n\t&#123;\n\t\t_materialList.Clear();\n\t\tUIPanel.RemoveRQ(this);\n\t&#125;\n&#125;</code></pre>\n\n<p>第二步，给两个UIPanel之间留下一定范围的renderQueue数值，并在UIPanel更新时修改模型的renderQueue。我们修改UIPanel.LateUpdate（注释为修改处）。</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">void LateUpdate()\n&#123;\n\tif(mUpdateFrame !&#x3D; Time.frameCount)\n\t&#123;\n\t\tmUpdateFrame &#x3D; Time.frameCount;\n\t\t\n\t\tfor(int i &#x3D; 0, imax &#x3D; list.Count; i &lt; imax; ++i)\n\t\t&#123;\n\t\t\tlist[i].UpdateSelf();\n\t\t&#125;\n\t\t\n\t\tint rq &#x3D; 3000;\n\t\tfor(int i &#x3D; 0, imax &#x3D; list.Count; i &lt; imax; ++i)\n\t\t&#123;\n\t\t\tUIPanel p &#x3D; list[i];\n\t\t\tif(p.renderQueue &#x3D;&#x3D; RenderQueue.Automatic)\n\t\t\t&#123;\n\t\t\t\tp.startingRenderQueue &#x3D; rq;\n\t\t\t\tp.UpdateDrawCalls();\n\t\t\t\trq +&#x3D; p.drawCalls.Count * 2;&#x2F;&#x2F;加上*2\n\t\t\t&#125;\n\t\t\telse if(p.renderQueue &#x3D;&#x3D; RenderQueue.StartAt)\n\t\t\t&#123;\n\t\t\t\tp.UpdateDrawCalls();\n\t\t\t\tif(p.drawCalls.Count !&#x3D; 0)\n\t\t\t\t&#123;\n\t\t\t\t\trq &#x3D; Mathf.Max(rq, p.startingRenderQueue + p.drawCalls.Count * 2);&#x2F;&#x2F;加上*2\n\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tp.UpdateDrawCalls();\n\t\t\t\tif(p.drawCalls.Count !&#x3D; 0)\n\t\t\t\t&#123;\n\t\t\t\t\trq &#x3D; Mathf.Max(rq, p.startingRenderQueue + 1 * 2);&#x2F;&#x2F;加上*2\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tUpdateModelRQ();&#x2F;&#x2F;加上刷新rq\n\t&#125;\n&#125;\n\nprivate static List&lt;RenderQueueControl&gt; _modelRQList &#x3D; new List&lt;RenderQueueControl&gt;();\n\npublic static void AddModelRQ(RenderQueueControl control)\n&#123;\n\tif(!_modelRQList.Contains(control))\n\t&#123;\n\t\t_modelRQList.Add(control);\n\t&#125;\n&#125;\n\npublic static void RemoveModelRQ(RenderQueueControl control)\n&#123;\n\t_modelRQList.Remove(control);\n&#125;\n\nprivate void UpdateModelRQ()\n&#123;\n\tfor(int i &#x3D; 0, len &#x3D; _modelRQList.Count; i &lt; len; i++)\n\t&#123;\n\t\tif(_modelRQList[i] &#x3D;&#x3D; null)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\t_modelRQList[i].UpdateRQ();\n\t&#125;\n&#125;</code></pre>\n\n<p>第三步，加载模型或特效后的调用</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public static void AddModelParent(GameObject modelGo, Transform parentTran)\n&#123;\n\tif(modelGo &#x3D;&#x3D; null || parentTran &#x3D;&#x3D; null || parentTran.gameObject &#x3D;&#x3D; null)\n\t&#123;\n\t\treturn;\n\t&#125;\n\tmodelGo.transform.parent &#x3D; parentTran;\n\t\n\tint layerUi &#x3D; parentTran.gameObject.layer;\n\tSetLayerRecursively(parentTran.gameObject, layerUi);\n\t\n\tRenderQueueControl rqControl &#x3D; modelGo.AddMissingComponent&lt;RenderQueueControl&gt;();\n\trqControl.Init();\n&#125;\n\npublic static void SetLayerRecursively(GameObject parent, int layer)\n&#123;\n\tif(parent &#x3D;&#x3D; null)\n\t&#123;\n\t\treturn;\n\t&#125;\n\tparent.layer &#x3D; layer;\n\tforeach(Transform child in parent.transform)\n\t&#123;\n\t\tif(child &#x3D;&#x3D; null)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tSetLayerRecursively(child.gameObject, layer);\n\t&#125;\n&#125;</code></pre>\n\n<p>效果图</p>\n","text":" 尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78477944 项目中经常遇到层级的显示问题，来总结下。 一，Unity按优先级从高到低排列： 1，Camera.depthdepth小的先渲染。 2...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"Unity","slug":"Unity","count":4,"path":"api/categories/Unity.json"}],"tags":[{"name":"Unity渲染层级 ngui渲染层级","slug":"Unity渲染层级-ngui渲染层级","count":1,"path":"api/tags/Unity渲染层级-ngui渲染层级.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%EF%BC%8CUnity\"><span class=\"toc-text\">一，Unity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%EF%BC%8CCamera-depth\"><span class=\"toc-text\">1，Camera.depth</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%EF%BC%8CRenderer-sortingLayerID\"><span class=\"toc-text\">2，Renderer.sortingLayerID</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%EF%BC%8CMaterial-renderQueue\"><span class=\"toc-text\">4，Material.renderQueue</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%EF%BC%8CNGUI\"><span class=\"toc-text\">二，NGUI</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%EF%BC%8CUIPanel-sortingOrder\"><span class=\"toc-text\">1，UIPanel.sortingOrder</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%EF%BC%8CUIPanel-depth\"><span class=\"toc-text\">2，UIPanel.depth</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%EF%BC%8CUIWidget-depth\"><span class=\"toc-text\">3，UIWidget.depth</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%EF%BC%8CNGUI%E4%B8%8E%E6%A8%A1%E5%9E%8B%E6%88%96%E7%89%B9%E6%95%88%E7%9A%84%E5%A4%B9%E5%B1%82%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">三，NGUI与模型或特效的夹层问题</span></a></li></ol>","author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ETC1+Alpha纹理压缩自动化脚本","uid":"0fcb6ec26ac7da2494cb667ad8d042c2","slug":"ETC1+Alpha纹理压缩自动化脚本","date":"2017-12-13T15:28:47.000Z","updated":"2022-07-16T11:30:57.116Z","comments":true,"path":"api/articles/ETC1+Alpha纹理压缩自动化脚本.json","keywords":null,"cover":[],"text":" 尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78798054 一，压缩方式 我们在Unity中对于图集和纹理，常用的压缩方案按照质量从低到高可以分为： 高压缩：Android:ETC1+Alpha...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"Ngui","slug":"Ngui","count":1,"path":"api/categories/Ngui.json"}],"tags":[{"name":"ETC1 Alpha","slug":"ETC1-Alpha","count":1,"path":"api/tags/ETC1-Alpha.json"}],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}