{"title":"Unity动画优化:Optimize Game Objects","uid":"3a0b1b76fc538b21ccd4834c8f7647d5","slug":"Unity动画优化!Optimize Game Objects","date":"2020-03-12T06:43:16.000Z","updated":"2022-07-16T11:30:57.118Z","comments":true,"path":"api/articles/Unity动画优化!Optimize Game Objects.json","keywords":null,"cover":[],"content":"<span id=\"more\"></span>\n\n<h3 id=\"一、Optimize-Game-Objects介绍\"><a href=\"#一、Optimize-Game-Objects介绍\" class=\"headerlink\" title=\"一、Optimize Game Objects介绍\"></a>一、Optimize Game Objects介绍</h3><p>Unity中FBX的导入设置,Inspector中Rig页签下有Optimize Game Objects选项，<br><img src=\"https://img-blog.csdnimg.cn/20200312143046411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhaTYxMjc4MQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>Unity官方文档的解释是：<br>In the GameObjects hierarchy of a character, the GameObjects which only contain Transform component, will be optimized out unless they are specified in extraExposedTransformPaths for better CPU performance. The remaining GameObjects hierarchy will be flattened.</p>\n<p>当勾选了该选项后，FBX中的骨骼节点，如果只有Transform组件，会被剔除不导入，<br>如果需要某些骨骼节点不被剔除，例如需要挂点，则需要在Extra Transform Paths中勾选对应的骨骼名称。<br>注意：不剔除的节点会被移到根节点之下，因此代码中不能通过原有路径查找（transform.Find(“Bip001&#x2F;Bip001 Spine”)）。</p>\n<p>原理：<br>Remove and store the GameObject Transform hierarchy of the imported character in the Avatar and Animator component. If enabled, the SkinnedMeshRenderers of the character use the Unity animation system’s internal skeleton, which improves the performance of the animated characters.<br>Only available if the Avatar Definition is set to Create From This Model.</p>\n<p>Unity会将骨骼信息映射到avatar中，这样，unity在更新骨骼矩阵时，不再考虑场景中的Transform节点，也不用更新它的坐标，而是直接通过获取avatar骨骼信息来更新蒙皮，表现动画，从而节省了cpu计算。</p>\n<h3 id=\"二、优化前后对比\"><a href=\"#二、优化前后对比\" class=\"headerlink\" title=\"二、优化前后对比\"></a>二、优化前后对比</h3><p>优化前模型结构：<br><img src=\"https://img-blog.csdnimg.cn/20200312143213881.png\" alt=\"在这里插入图片描述\"><br>优化后模型结构：<br><img src=\"https://img-blog.csdnimg.cn/20200312143233549.png\" alt=\"在这里插入图片描述\"><br>Animator.hasTransformHierarchy会变为false<br>SkinMeshRender.rootBone会变为空</p>\n<h3 id=\"三、代码\"><a href=\"#三、代码\" class=\"headerlink\" title=\"三、代码\"></a>三、代码</h3><p>对应接口：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">AnimatorUtility.DeoptimizeTransformHierarchy(GameObject go);\nAnimatorUtility.OptimizeTransformHierarchy(GameObject go, string[] exposedTransforms)</code></pre>\n\n<p>不过我们项目是把fbx内嵌在模型prefab中，使用该接口会报错：<br><img src=\"https://img-blog.csdnimg.cn/20200312143539587.png\" alt=\"在这里插入图片描述\"><br>因此改用修改ModelImporter的方式。<br>另外我们会有些虚拟挂载点绑定在骨骼下。<br>因此需要在编辑挂载点前显示所有骨骼，编辑好后优化剔除无用的骨骼。</p>\n<p>取消优化：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public static void UndoOptimize(GameObject root)\n        &#123;\n            var animator &#x3D; root.GetComponentInChildren&lt;Animator&gt;();&#x2F;&#x2F;Animator组件挂在fbx节点上\n            if (animator &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n\n            var fbxGo &#x3D; animator.gameObject;\n            var fbxPath &#x3D; AssetDatabase.GetAssetPath(PrefabUtility.GetCorrespondingObjectFromSource(fbxGo));&#x2F;&#x2F;获取fbx在Project中的路径\n            \n            var importer &#x3D; AssetImporter.GetAtPath(fbxPath) as ModelImporter;\n            if (importer &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n            importer.optimizeGameObjects &#x3D; false;\n            importer.SaveAndReimport();\n        &#125;</code></pre>\n\n<p>优化：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public static void Optimize(GameObject root)\n        &#123;\n            var animator &#x3D; root.GetComponentInChildren&lt;Animator&gt;();\n            if (animator &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n\n            var fbxGo &#x3D; animator.gameObject;\n            var dummys &#x3D; root.GetComponentsInChildren&lt;DummyData&gt;();&#x2F;&#x2F;自定义的虚拟挂载点\n            List&lt;string&gt; exposedTransNameList &#x3D; new List&lt;string&gt;();\n            foreach (var dummy in dummys)\n            &#123;\n                if (dummy.Parent !&#x3D; null &amp;&amp; dummy.Parent !&#x3D; dummy.Root)&#x2F;&#x2F;筛选绑在骨骼上的挂载点\n                &#123;\n                    var fullPath &#x3D; AnimationUtility.CalculateTransformPath(dummy.Parent.transform, fbxGo.transform);&#x2F;&#x2F;获取骨骼的完整路径\n                    exposedTransNameList.Add(fullPath);\n                &#125;\n            &#125;\n            \n            var fbxPath &#x3D; AssetDatabase.GetAssetPath(PrefabUtility.GetCorrespondingObjectFromSource(fbxGo));\n            var importer &#x3D; AssetImporter.GetAtPath(fbxPath) as ModelImporter;\n            if (importer &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n            importer.optimizeGameObjects &#x3D; true;\n            importer.extraExposedTransformPaths &#x3D; exposedTransNameList.ToArray();\n            importer.SaveAndReimport();\n        &#125;</code></pre>\n\n<p>优化后可以看到fbx meta文件变化：<br><img src=\"https://img-blog.csdnimg.cn/20200312143946235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhaTYxMjc4MQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","text":" 一、Optimize Game Objects介绍Unity中FBX的导入设置,Inspector中Rig页签下有Optimize Game Objects选项，Unity官方文档的解释是：In the GameObjects hierarchy of a character,...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Unity Optimize","slug":"Unity-Optimize","count":1,"path":"api/categories/Unity-Optimize.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Optimize-Game-Objects%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">一、Optimize Game Objects介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E4%BC%98%E5%8C%96%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">二、优化前后对比</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">三、代码</span></a></li></ol>","author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"脚本解析photoshop文本属性","uid":"5992dcd2bf88f595edc9caf556b4762c","slug":"脚本解析photoshop文本属性","date":"2017-09-23T10:35:11.000Z","updated":"2022-07-16T12:23:29.694Z","comments":true,"path":"api/articles/脚本解析photoshop文本属性.json","keywords":null,"cover":[],"text":" 尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78072531 在做unity项目中，用到了psd2ngui插件来把psd直接导出成prefab，psd2ngui的原理就是解析psd中图层的命名来生...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"PhotoShop","slug":"PhotoShop","count":2,"path":"api/categories/PhotoShop.json"}],"tags":[{"name":"photoshop script ps script actionmanager","slug":"photoshop-script-ps-script-actionmanager","count":1,"path":"api/tags/photoshop-script-ps-script-actionmanager.json"}],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"bilibili发送弹幕","uid":"d0e1bfe93c0db1f072a3c290822ee8c7","slug":"bilibili发送弹幕","date":"2020-02-23T17:51:40.000Z","updated":"2022-07-16T11:30:57.119Z","comments":true,"path":"api/articles/bilibili发送弹幕.json","keywords":null,"cover":[],"text":" 前言媳妇儿玩起了bilibili直播，我就顺便研究下利用python发送弹幕，以表支持～，主要思路通过发送http请求。 发送弹幕1. 查询http请求首先登录b站，进入直播间，打开开发者工具，先在直播间发送一条弹幕。 可以看到请求的url地址，请求方式是post，以及请求的表...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"Python","slug":"Python","count":1,"path":"api/categories/Python.json"}],"tags":[],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}