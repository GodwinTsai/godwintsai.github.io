{"title":"批量删除预制脚本","uid":"cf6a4766c3507937614ad6819b2f17d9","slug":"批量删除预制脚本","date":"2020-01-02T16:54:06.000Z","updated":"2022-07-16T11:30:57.000Z","comments":true,"path":"api/articles/批量删除预制脚本.json","keywords":null,"cover":[],"content":"<span id=\"more\"></span>\n\n<h3 id=\"环境：Unity-2018-4-12\"><a href=\"#环境：Unity-2018-4-12\" class=\"headerlink\" title=\"环境：Unity 2018.4.12\"></a>环境：Unity 2018.4.12</h3><h3 id=\"需求：\"><a href=\"#需求：\" class=\"headerlink\" title=\"需求：\"></a>需求：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">项目中经常需要在Unity Editor模式下批量删除Prefab中的某个脚本，但是直接用&#96;GameObject.DestroyImmediate(obj);&#96;会报错：Destroying assets is not permitted to avoid data loss.解决方法是通过&#96;SerializedProperty.DeleteArrayElementAtIndex(i)&#96;。</code></pre>\n\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">private bool RemoveComponents(Component[] components)\n        &#123;\n            if (components.Length &#x3D;&#x3D; 0)\n            &#123;\n                return false;\n            &#125;\n            foreach (var component in components)\n            &#123;\n                SerializedObject so &#x3D; new SerializedObject(component.gameObject);\n                SerializedProperty sp &#x3D; so.FindProperty(&quot;m_Component&quot;);\n\n                var allComponents &#x3D; component.gameObject.GetComponents&lt;Component&gt;();\n                for (int i &#x3D; 0, len &#x3D; allComponents.Length; i &lt; len; i++)\n                &#123;\n                    if (allComponents[i] &#x3D;&#x3D; component)\n                    &#123;\n                        sp.DeleteArrayElementAtIndex(i);\n                        so.ApplyModifiedProperties();\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n\n            return true;\n        &#125;</code></pre>\n\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public  bool RemoveComponents&lt;T&gt;(GameObject root) where T : Component\n        &#123;\n            if (root &#x3D;&#x3D; null)\n            &#123;\n                return false;\n            &#125;\n            var components &#x3D; root.GetComponentsInChildren&lt;T&gt;(true);\n            return RemoveComponents(components);\n        &#125;</code></pre>\n\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">为了方便使用，实现一个EditorWindow来操作，代码如下：</code></pre>\n\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">using UnityEditor;\nusing UnityEngine;\n\nnamespace Common.Editor.Common\n&#123;\n    public class RemoveComponentEditor : EditorWindow\n    &#123;\n        private static RemoveComponentEditor _instance;\n        private static string[] _selectAssets;\n        private static string _key;\n        private static MonoScript _monoScript;\n        \n        [MenuItem(&quot;PrefabTool&#x2F;RemoveComponentEditor&quot;)]\n        public static void ShowWindow()\n        &#123;\n            _instance &#x3D; GetWindow(typeof(RemoveComponentEditor)) as RemoveComponentEditor;\n            _instance.Show();\n        &#125;\n        \n        void OnGUI()\n        &#123;\n            _selectAssets &#x3D; Selection.assetGUIDs;\n            if (_selectAssets &#x3D;&#x3D; null || _selectAssets.Length &#x3D;&#x3D; 0)\n            &#123;\n                EditorGUILayout.LabelField(&quot;No Assets Selected&quot;);\n            &#125;\n            else\n            &#123;\n                EditorGUILayout.LabelField($&quot;Selected Assets：\\n&quot;);\n                foreach (var asset in _selectAssets)\n                &#123;\n                    var path &#x3D; AssetDatabase.GUIDToAssetPath(asset);\n                    EditorGUILayout.LabelField($&quot;&#123;path&#125;\\n&quot;);\n                &#125;\n            &#125;\n\n            _key &#x3D; EditorGUILayout.TextField(&quot;Prefab Name Key:&quot;, _key);\n            _monoScript &#x3D; EditorGUILayout.ObjectField(&quot;Script&quot;, _monoScript, typeof(MonoScript), false) as MonoScript;\n            if (GUILayout.Button(&quot;Remove&quot;))\n            &#123;\n                Remove();\n            &#125;\n        &#125;\n\n        private void Remove()\n        &#123;\n            if (_selectAssets &#x3D;&#x3D; null || _selectAssets.Length &#x3D;&#x3D; 0)\n            &#123;\n                EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please Select A Folder Or Asset&quot;, &quot;OK&quot;);\n                return;\n            &#125;\n\n            if (_monoScript &#x3D;&#x3D; null)\n            &#123;\n                EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please Select A Mono Script&quot;, &quot;OK&quot;);\n                return;\n            &#125;\n\n            var prefabs &#x3D; CommonToolUtil.GetSelectPrefabs(_key);\n            CommonToolUtil.ExecutePrefabs(prefabs, Execute, &quot;Execute&quot;, true);\n        &#125;\n        \n        private bool Execute(GameObject prefab)\n        &#123;\n            return CommonToolUtil.RemoveComponents(prefab, _monoScript);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>GetSelectPrefabs()函数用来获得选中目录下的所有Prefabs,参数key用来过滤Prefab的名字，因为一个文件夹下可能有多个采用不同前后缀命名的Variant：</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public static List&lt;GameObject&gt; GetSelectPrefabs(string key)\n        &#123;\n            List&lt;GameObject&gt; list &#x3D; new List&lt;GameObject&gt;();\n            Object[] selectedAssets &#x3D; Selection.GetFiltered(typeof(Object), SelectionMode.DeepAssets);\n            foreach (Object asset in selectedAssets)\n            &#123;\n                string filePath &#x3D; AssetDatabase.GetAssetPath(asset);\n                if (!filePath.EndsWith(&quot;.prefab&quot;))\n                &#123;\n                    continue;\n                &#125;\n\n                if (!string.IsNullOrEmpty(key))\n                &#123;\n                    var fileName &#x3D; Path.GetFileNameWithoutExtension(filePath);\n                    if (!fileName.Contains(key))\n                    &#123;\n                        continue;\n                    &#125;\n                &#125;\n                \n                var prefab &#x3D; AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(filePath);\n                if (prefab &#x3D;&#x3D; null)\n                &#123;\n                    continue;\n                &#125;\n                list.Add(prefab);\n            &#125;\n            return list;\n        &#125;</code></pre>\n\n<p>ExecutePrefabs函数遍历Prefabs，并显示进度条，有修改则保存</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public static void ExecutePrefabs(List&lt;GameObject&gt; prefabs, Func&lt;GameObject, bool&gt; action, string content, bool save &#x3D; true)\n        &#123;\n            var count &#x3D; prefabs.Count;\n            var index &#x3D; 0;\n            foreach (var prefab in prefabs)\n            &#123;\n                EditorUtility.DisplayProgressBar(content,\n                    $&quot;&#123;content&#125;...&#123;++index&#125;&#x2F;&#123;count&#125;&quot;, (float) index &#x2F; count);\n                bool result &#x3D; action.Invoke(prefab);\n                if (save &amp;&amp; result)\n                &#123;\n                    PrefabUtility.SavePrefabAsset(prefab);\n                &#125;\n            &#125;\n\n            if (save)\n            &#123;\n                AssetDatabase.SaveAssets();\n                AssetDatabase.Refresh();\n            &#125;\n            \n            EditorUtility.ClearProgressBar();\n        &#125;</code></pre>\n\n<p>RemoveComponents函数通过MonoScript获得Component数组，调用上面的方法移除组件</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public static bool RemoveComponents(GameObject root, MonoScript monoScript)\n        &#123;\n            if (root &#x3D;&#x3D; null || monoScript &#x3D;&#x3D; null)\n            &#123;\n                return false;\n            &#125;\n\n            var type &#x3D; monoScript.GetClass();\n            if (type &#x3D;&#x3D; null)\n            &#123;\n                return false;\n            &#125;\n\n            var components &#x3D; root.GetComponentsInChildren(type);\n            return RemoveComponents(components);\n        &#125;</code></pre>\n\n<p>运行效果如图：<br>可以选择目录或预制，设置关键词过滤，选择要删除的组件<br><img src=\"https://img-blog.csdnimg.cn/20200103004743870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhaTYxMjc4MQ==,size_16,color_FFFFFF,t_70\" alt=\"Editor\"></p>\n","text":" 环境：Unity 2018.4.12需求：项目中经常需要在Unity Editor模式下批量删除Prefab中的某个脚本，但是直接用&#96;GameObject.DestroyImmediate(obj);&#96;会报错：Destroying assets is not p...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"Unity","slug":"Unity","count":5,"path":"api/categories/Unity.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%EF%BC%9AUnity-2018-4-12\"><span class=\"toc-text\">环境：Unity 2018.4.12</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9C%80%E6%B1%82%EF%BC%9A\"><span class=\"toc-text\">需求：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">代码：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">工具</span></a></li></ol>","author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"bilibili发送弹幕","uid":"d0e1bfe93c0db1f072a3c290822ee8c7","slug":"bilibili发送弹幕","date":"2020-02-23T17:51:40.000Z","updated":"2022-07-16T11:30:57.000Z","comments":true,"path":"api/articles/bilibili发送弹幕.json","keywords":null,"cover":[],"text":" 前言媳妇儿玩起了bilibili直播，我就顺便研究下利用python发送弹幕，以表支持～，主要思路通过发送http请求。 发送弹幕1. 查询http请求首先登录b站，进入直播间，打开开发者工具，先在直播间发送一条弹幕。 可以看到请求的url地址，请求方式是post，以及请求的表...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"Python","slug":"Python","count":1,"path":"api/categories/Python.json"}],"tags":[],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Timeline Note--引用无关资源","uid":"278122282ab7fc90233764072d390801","slug":"Timeline Note--引用无关资源","date":"2019-08-21T04:09:46.000Z","updated":"2022-07-16T11:30:57.000Z","comments":true,"path":"api/articles/Timeline Note--引用无关资源.json","keywords":null,"cover":[],"text":" 一，环境：Unity 2018.4.2 二，结构一个Prefab一段Timeline演出，Prefab上会挂PlayableDirector组件，并绑定Timeline Asset。Timeline Asset的编辑内容 三，现象对预制执行Select Dependencies...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Timeline","slug":"Timeline","count":2,"path":"api/categories/Timeline.json"}],"tags":[{"name":"Timeline 坑 资源引用 资源依赖","slug":"Timeline-坑-资源引用-资源依赖","count":1,"path":"api/tags/Timeline-坑-资源引用-资源依赖.json"}],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}