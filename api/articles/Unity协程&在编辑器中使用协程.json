{"title":"Unity协程&在编辑器中使用协程","uid":"21ad9801a0836d599aef927bc9336390","slug":"Unity协程&在编辑器中使用协程","date":"2018-01-06T17:42:45.000Z","updated":"2022-07-16T11:30:57.119Z","comments":true,"path":"api/articles/Unity协程&在编辑器中使用协程.json","keywords":null,"cover":null,"content":"<span id=\"more\"></span>\n\n<h2 id=\"尊重原创，转载请在文首注明出处：http-blog-csdn-net-cai612781-article-details-78992805\"><a href=\"#尊重原创，转载请在文首注明出处：http-blog-csdn-net-cai612781-article-details-78992805\" class=\"headerlink\" title=\"尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78992805\"></a>尊重原创，转载请在文首注明出处：<a href=\"http://blog.csdn.net/cai612781/article/details/78992805\">http://blog.csdn.net/cai612781/article/details/78992805</a></h2><h2 id=\"一，定义\"><a href=\"#一，定义\" class=\"headerlink\" title=\"一，定义\"></a>一，定义</h2><p>Unity协程(Coroutine)，不是卖机票的携程，是一种类似子线程的机制，可以用来实现一些延时处理的需求，c#中通过yield return语句配合可以中断执行，延时一定时间后从中断处继续执行。</p>\n<h2 id=\"二，注意\"><a href=\"#二，注意\" class=\"headerlink\" title=\"二，注意\"></a>二，注意</h2><p>协程不是线程，协程不是线程，协程不是线程，协程还是在主线程里！！！</p>\n<h2 id=\"三，语法\"><a href=\"#三，语法\" class=\"headerlink\" title=\"三，语法\"></a>三，语法</h2><p>脚本需要继承MonoBehaviour，提供了两个方法StartCoroutine(IEnumerator routine)或者StartCoroutine(string methodName)开启一个协程，以及对应的StopCoroutine(IEnumerator routine)或StopCoroutine(string methodName)关闭协程。推荐使用前者，因为传递方法名需要用到反射机制，影响性能。</p>\n<h2 id=\"四，常见应用\"><a href=\"#四，常见应用\" class=\"headerlink\" title=\"四，常见应用\"></a>四，常见应用</h2><p>1）延时（别想歪）</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">using UnityEngine;\nusing System.Collections;\n\npublic class ExampleClass : MonoBehaviour\n&#123;\n\tIEnumerator Start()\n\t&#123;\n\t\tDebug.Log(&quot;Start--&quot; + Time.time);\n\t\tyield return StartCoroutine(WaitAndLog);\n\t\tDebug.Log(&quot;End--&quot; + Time.time);\n\t&#125;\n\t\n\tIEnumerator WaitAndLog()\n\t&#123;\n\t\tyield return new WaitForSeconds(3);\n\t\tDebug.Log(&quot;Wait--&quot; + Time.time);\n\t&#125;\n&#125;</code></pre>\n\n<p>2）分帧加载</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">using UnityEngine;\nusing System.Collections;\n\npublic class ExampleClass : MonoBehaviour\n&#123;\n\tprivate int _num,_total;\n\tStart()\n\t&#123;\n\t\tStartCoroutine(LoadAssets);\n\t&#125;\n\t\n\tIEnumerator LoadAssets()\n\t&#123;\n\t\twhile(_num &lt; _total)\n\t\t&#123;\n\t\t\t_num++;\n\t\t\tDebug.Log(&quot;Load an Asset&quot;);\n\t\t\tyield return null;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"五，yield\"><a href=\"#五，yield\" class=\"headerlink\" title=\"五，yield\"></a>五，yield</h2><p>yield语句用于暂停协程的执行，yield return 的值决定什么时候恢复协程的执行。yield return 返回一个IEnumerator对象，当该对象的MoveNext()返回false，即该对象的Current已迭代到最后一个元素时，才会执行yield return后的代码。</p>\n<p>yield语句的返回有如下类型：</p>\n<p>yield return null;&#x2F;&#x2F;下一帧再继续往下执行</p>\n<p>yield return new WaitForFixedUpdate();&#x2F;&#x2F;等到下一次调用FixedUpdate再往下执行</p>\n<p>yield return new WaitForSceonds(n);&#x2F;&#x2F;等待n秒再往下执行</p>\n<p>yield return StartCoroutine(Method);&#x2F;&#x2F;开启另一个协程，直到Method执行完毕再往下执行</p>\n<p>yield return new WaitForEndOfFrame();&#x2F;&#x2F;等到该帧结束再往下执行</p>\n<p>yield return WWW;&#x2F;&#x2F;等待资源加载完成再往下执行</p>\n<p>yield break;&#x2F;&#x2F;结束协程</p>\n<h2 id=\"六，执行顺序\"><a href=\"#六，执行顺序\" class=\"headerlink\" title=\"六，执行顺序\"></a>六，执行顺序</h2><p>协程是每帧lateUpdate前执行yield return之前的代码，lateUpdate后执行yield return之后的代码。</p>\n<p>不同yield return返回值的执行顺序，通过官方文档的一张流程图可以清晰地了解：</p>\n<p><a href=\"http://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg\">http://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg</a>  </p>\n<h2 id=\"七，原理\"><a href=\"#七，原理\" class=\"headerlink\" title=\"七，原理\"></a>七，原理</h2><p>Unity的协程应该是一个扩展成支持嵌套的迭代器（IEnumator）。</p>\n<p>它将c# IEnumerator封装为Coroutine对象，它记录了该协程的上一级协程是谁，当这个协程执行完成，会继续执行上一级协程。</p>\n<p>当Unity Coroutine调用IEnumerator的MoveNext返回一个新Coroutine时，Unity设置新对象的上级Coroutine为当前Coroutine，同时将新Coroutine压入队列，通过此实现嵌套。</p>\n<p>然后Unity在主线程中定时检测当前每个等待的Coroutine，满足条件则执行。</p>\n<h2 id=\"八，在Editor下使用Coroutine\"><a href=\"#八，在Editor下使用Coroutine\" class=\"headerlink\" title=\"八，在Editor下使用Coroutine\"></a>八，在Editor下使用Coroutine</h2><p>编辑器下因为没有运行Unity，也没有创建GameObject，因此也无法通过Monobehaviour的StartCoroutine创建协程。</p>\n<p>以下代码来自网上不知哪位大牛，根据Unity协程原理另外实现了个协程：</p>\n<p>1，EditorCoroutine协程类实现了IEnumerator接口，在MoveNext函数中实现了嵌套调用协程</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public class EditorCoroutine : IEnumerator  \n    &#123;  \n        private Stack&lt;IEnumerator&gt; executionStack;  \n  \n        public EditorCoroutine(IEnumerator iterator)  \n        &#123;  \n            this.executionStack &#x3D; new Stack&lt;IEnumerator&gt;();  \n            this.executionStack.Push(iterator);  \n        &#125;  \n  \n        public bool MoveNext()  \n        &#123;  \n            IEnumerator i &#x3D; this.executionStack.Peek();  \n  \n            if (i.MoveNext())  \n            &#123;  \n                object result &#x3D; i.Current;  \n                if (result !&#x3D; null &amp;&amp; result is IEnumerator)  \n                &#123;  \n                    this.executionStack.Push((IEnumerator)result);  \n                &#125;  \n  \n                return true;  \n            &#125;  \n            else  \n            &#123;  \n                if (this.executionStack.Count &gt; 1)  \n                &#123;  \n                    this.executionStack.Pop();  \n                    return true;  \n                &#125;  \n            &#125;  \n  \n            return false;  \n        &#125;  \n  \n        public void Reset()  \n        &#123;  \n            throw new System.NotSupportedException(&quot;This Operation Is Not Supported.&quot;);  \n        &#125;  \n  \n        public object Current  \n        &#123;  \n            get &#123; return this.executionStack.Peek().Current; &#125;  \n        &#125;  \n  \n        public bool Find(IEnumerator iterator)  \n        &#123;  \n            return this.executionStack.Contains(iterator);  \n        &#125;  \n    &#125;  </code></pre>\n\n<p>2，EditorCoroutineRunner类，类似MonoBehaviour，提供了StartEditorCoroutine方法创建一个协程</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">public static class EditorCoroutineRunner  \n&#123;      \n    private static List&lt;EditorCoroutine&gt; editorCoroutineList;  \n    private static List&lt;IEnumerator&gt; buffer;  \n  \n    public static IEnumerator StartEditorCoroutine(IEnumerator iterator)  \n    &#123;  \n        if (editorCoroutineList &#x3D;&#x3D; null)  \n        &#123;  \n            editorCoroutineList &#x3D; new List&lt;EditorCoroutine&gt;();  \n        &#125;  \n        if (buffer &#x3D;&#x3D; null)  \n        &#123;  \n            buffer &#x3D; new List&lt;IEnumerator&gt;();  \n        &#125;  \n        if (editorCoroutineList.Count &#x3D;&#x3D; 0)  \n        &#123;  \n            EditorApplication.update +&#x3D; Update;  \n        &#125;  \n  \n        buffer.Add(iterator);  \n      \n        return iterator;  \n    &#125;  \n  \n    private static bool Find(IEnumerator iterator)  \n    &#123;   \n        foreach (EditorCoroutine editorCoroutine in editorCoroutineList)  \n        &#123;  \n            if (editorCoroutine.Find(iterator))  \n            &#123;  \n                return true;  \n            &#125;  \n        &#125;  \n  \n        return false;  \n    &#125;  \n  \n    private static void Update()  \n    &#123;  \n        editorCoroutineList.RemoveAll  \n        (  \n            coroutine &#x3D;&gt; &#123; return coroutine.MoveNext() &#x3D;&#x3D; false; &#125;  \n        );  \n  \n\n        if (buffer.Count &gt; 0)  \n        &#123;  \n            foreach (IEnumerator iterator in buffer)  \n            &#123;  \n                if (!Find(iterator))  \n                &#123;  \n                    editorCoroutineList.Add(new EditorCoroutine(iterator));  \n                &#125;  \n            &#125;  \n  \n            buffer.Clear();  \n        &#125;  \n  \n        if (editorCoroutineList.Count &#x3D;&#x3D; 0)  \n        &#123;  \n            EditorApplication.update -&#x3D; Update;  \n        &#125;  \n    &#125;  \n&#125;  </code></pre>\n\n<p>3，调用</p>\n<pre class=\"line-numbers language-csharp\" data-language=\"csharp\"><code class=\"language-csharp\">using UnityEngine;\nusing System.Collections;\n\npublic class ExampleClass\n&#123;\n\tStart()\n\t&#123;\n\t\tEditorCoroutineRunner.StartEditorCoroutine(Routine);\n\t&#125;\n\t\n\tIEnumerator Routine()\n\t&#123;\n\t\tDebug.Log(&quot;Routine&quot;);\n\t\tyield return null;\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"九，参考\"><a href=\"#九，参考\" class=\"headerlink\" title=\"九，参考\"></a>九，参考</h2><p><a href=\"http://gad.qq.com/article/detail/10552\">http://gad.qq.com/article/detail/10552</a>  </p>\n<p><a href=\"http://blog.csdn.net/langresser_king/article/details/44244369\">http://blog.csdn.net/langresser_king/article/details/44244369</a></p>\n","text":" 尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78992805一，定义Unity协程(Coroutine)，不是卖机票的携程，是一种类似子线程的机制，可以用来实现一些延时处理的需求，c#中通过yie...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"Unity","slug":"Unity","count":4,"path":"api/categories/Unity.json"}],"tags":[{"name":"unity coroutine unity协程 use coroutine in uni 编辑器中使用协程","slug":"unity-coroutine-unity协程-use-coroutine-in-uni-编辑器中使用协程","count":1,"path":"api/tags/unity-coroutine-unity协程-use-coroutine-in-uni-编辑器中使用协程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8A%E9%87%8D%E5%8E%9F%E5%88%9B%EF%BC%8C%E8%BD%AC%E8%BD%BD%E8%AF%B7%E5%9C%A8%E6%96%87%E9%A6%96%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%EF%BC%9Ahttp-blog-csdn-net-cai612781-article-details-78992805\"><span class=\"toc-text\">尊重原创，转载请在文首注明出处：http:&#x2F;&#x2F;blog.csdn.net&#x2F;cai612781&#x2F;article&#x2F;details&#x2F;78992805</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%EF%BC%8C%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">一，定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%EF%BC%8C%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">二，注意</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%EF%BC%8C%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">三，语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%EF%BC%8C%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">四，常见应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%EF%BC%8Cyield\"><span class=\"toc-text\">五，yield</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%EF%BC%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">六，执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83%EF%BC%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">七，原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%EF%BC%8C%E5%9C%A8Editor%E4%B8%8B%E4%BD%BF%E7%94%A8Coroutine\"><span class=\"toc-text\">八，在Editor下使用Coroutine</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%9D%EF%BC%8C%E5%8F%82%E8%80%83\"><span class=\"toc-text\">九，参考</span></a></li></ol>","author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C#调用SVN","uid":"46fb15b5cb654d863634ab785c7560a1","slug":"CSharp调用SVN","date":"2018-01-09T09:10:37.000Z","updated":"2022-07-16T14:45:06.484Z","comments":true,"path":"api/articles/CSharp调用SVN.json","keywords":null,"cover":null,"text":" 尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/79015085 一，语法 项目开发中通常都会使用Subversion(SVN)作为版本控制系统，同时会使用SVN的客户端软件TortoiseSVN。 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"C#","slug":"C","count":4,"path":"api/categories/C.json"}],"tags":[{"name":"C#调用SVN","slug":"C-调用SVN","count":1,"path":"api/tags/C-调用SVN.json"}],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"ETC1+Alpha纹理压缩自动化脚本","uid":"0fcb6ec26ac7da2494cb667ad8d042c2","slug":"ETC1+Alpha纹理压缩自动化脚本","date":"2017-12-13T15:28:47.000Z","updated":"2022-07-16T11:30:57.116Z","comments":true,"path":"api/articles/ETC1+Alpha纹理压缩自动化脚本.json","keywords":null,"cover":[],"text":" 尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78798054 一，压缩方式 我们在Unity中对于图集和纹理，常用的压缩方案按照质量从低到高可以分为： 高压缩：Android:ETC1+Alpha...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"Ngui","slug":"Ngui","count":1,"path":"api/categories/Ngui.json"}],"tags":[{"name":"ETC1 Alpha","slug":"ETC1-Alpha","count":1,"path":"api/tags/ETC1-Alpha.json"}],"author":{"name":"GodwinTsai","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/GodwinTsai","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}