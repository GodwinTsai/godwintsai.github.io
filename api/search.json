[{"id":"9445c1590d18cd4588eaa614d62d2feb","title":"Skill&Buff Editor","content":"\n\n\n\n之前项目做的一个moba的skill&amp;buff编辑器，采用winform实现，独立于Unity。\n主编辑窗口（图中左上角），通过c# Attribute，反射技能逻辑的字段，采用节点和连线编辑，独立于具体的技能逻辑。\n节点的属性编辑（图中右上角）通过扩展winform的profertygrid，实现了包括下拉选择、下拉多选、自定义类列表、自定义类字典等多种格式编辑（如图中右下角为点击“使用条件”的二级配置窗口）\n可通过内嵌Unity窗口（图中左下角），可也自己打开项目Unity技能测试场景，通过socket连接，编辑好技能后实时重新加载配置，测试技能。\n后续再详细总结每个部分的实现\n\n","slug":"Skill&Buff Editor","date":"2020-04-02T02:57:25.000Z","categories_index":"C#","tags_index":"Unity","author_index":"GodwinTsai"},{"id":"3ec350ecf5fdab2807ec97539f38afce","title":"Unity世界坐标局部坐标转换","content":"\n\nworld pos -&gt; ui local pos世界坐标转UI局部坐标比较常用，也比较简单。\nVector3 worldPosition &#x3D; _3dTransform.position;\nVector3 screenPosition &#x3D; _3dCamera.WorldToScreenPoint(worldPosition);\n\nVector2 localPostion;\nif (RectTransformUtility.ScreenPointToLocalPointInRectangle((RectTransform)_canvas.transform, screenPosition, _canvas.worldCamera, out localPostion))\n&#123;\n    _2dTransform.localPosition &#x3D; localPostion;\n&#125;\n\nui local pos -&gt; world pos\n如果知道UI物件，直接通过transform.position获得。\n\n如果只知道UI父节点以及一个相对于父节点的局部坐标，可以通过：\nworldPos &#x3D; parentTransform.TransformPoint(localPos);\n\n如果只知道一个UI坐标，需要先转到屏幕坐标系，再转到世界坐标系：\n\n\n首先主要考虑的是UI适配，通常canvas scale会设置成Scale With Screen Size，Canvas大小就不一定是屏幕分辨率的大小。\n\n假设原本的标准分辨率是720x1280，在ipad的分辨率1536x2048上显示时：\n\n假如是以高度为适配，那么Canvas 实际高度为1280，宽度为1536 / 2048 \\* 1280 = 960，拉伸比例为2048 / 1280 = 1.6;\n\n假如是以宽度为适配，那么Canvas实际宽度为720，高度为2048 / 1536 \\* 720 = 960，拉伸比例为1536 / 720 = 2.13;\n\n那么屏幕坐标 = Canvas下的UI局部坐标 \\* 拉伸比例 + 屏幕宽高 / 2;\n\n因为Canvas UI局部坐标系的原点在中间，而屏幕坐标系的原点在左下角。\n\n接着再通过ScreenToWorldPoint\\(screenPos\\)转为世界坐标。\n\n代码如下：\n\nvar standardSize &#x3D; new Vector2(720f, 1280f);\nvar scale &#x3D; canvasScaler.matchWidthOrHeight &#x3D;&#x3D; 0\n    ? Screen.width &#x2F; standardSize.x\n    : Screen.height &#x2F; standardSize.y;\nvar screenPos &#x3D; localPos * scale + 0.5f * new Vector2(Screen.width, Screen.height);\nvar worldPos &#x3D; new Vector3();\n RectTransformUtility.ScreenPointToWorldPointInRectangle((RectTransform) canvas.transform, screenPos, uiCamera, out worldPos);\n\n\n如果只是为了获得偏移，可以简单地通过比例来获得：worldOffsetY &#x2F; uicamera.orthographicSize * 2 &#x3D; uiOffsetY &#x2F; Screen.height\n\n","slug":"Unity世界坐标局部坐标转换","date":"2020-04-01T12:23:08.000Z","categories_index":"Unity","tags_index":"","author_index":"GodwinTsai"},{"id":"5992dcd2bf88f595edc9caf556b4762c","title":"脚本解析photoshop文本属性","content":"\n\n尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78072531\n在做unity项目中，用到了psd2ngui插件来把psd直接导出成prefab，psd2ngui的原理就是解析psd中图层的命名来生成组件。用的还是最早的版本，插件中导出的文本只有一个文本内容，其余属性例如颜色、字号、描边、投影都得另外设置，很麻烦，新版不知有没这功能，一直没有继续研究。于是当时就有了这么个想法，写个ps脚本，解析文本的属性并命名，再扩展插件来实现导出ui后不用额外修改文本属性。这也是很早很早之前做的，现在来总结下。\n语言ps支持几种脚本语言，Mac平台有AppleScript,Windows平台有VBScript，以及两个平台都支持的JavaScript。我用的就是Js语言，后缀是jsx。\n工具可以使用任何文本编辑来写代码，这里推荐Adobe的IDE，叫Adobe ExtendScript Tookit，支持断点调试，还可以通过Data Browser窗口查看对象的属性和方法。\n  \n语法ps script一种方式是通过文本对象模型DOM（Document Object Model）来访问和修改psd中的对象的属性，直观而方便，但不能实现所有的ps操作。 \nps dom类结构图：\n  \n另一种方式是通过动作代理(ActionManager)的方式，可以实现比DOM更多的操作，但貌似不支持AppleScript。\n动作代理主要类有ActionDescriptor，ActionReference，ActionList。\nActionDescriptor相当于一个存储属性和值的字典,\nActionList是一个存储相同属性的值的数组，\nActionReference存储一个action的引用，\n举个栗子：\nfunction emboss(inAngle, inHeight, inAmount)\n&#123;\n\tvar keyAngleID &#x3D; charIDToTypeID(&quot;Angl&quot;);\n\tvar keyHeightID &#x3D; charIDToTypeID(&quot;Hght&quot;);\n\tvar keyAmountID &#x3D; charIDToTypeID(&quot;Amnt&quot;);\n\tvar eventEmbossID &#x3D; charIDToTypeID(&quot;Embs&quot;);\n\t\n\tvar filterDescriptor &#x3D; new ActionDescriptor();\n\tfilterDescriptor.putInteger(keyAngleID, inAngle);\n\tfilterDescriptor.putInteger(keyHeightID, inHeight);\n\tfilterDescriptor.putInteger(keyAmountID, inAmount);\n\t\n\texecuteAction(eventEmbossID, filterDescriptor);\n&#125;\n\nemboss(120, 10, 100);\n\n运行该脚本，会给选中图层添加一个浮雕滤镜\n插件ActionManager看起来比DOM复杂繁琐，好在Adobe有个监听Action的插件，下载地址：\nWindows： ScriptingListenerPlugInForWindow \nMac：ScriptingListenerPlugInForMac \n下载解压后将ScriptListener.8li拷贝到Adobe Photoshop&#x2F;Plug-ins&#x2F;目录下即可。\n重开ps，操作将会被记录在桌面的ScriptingListenerJS.log和ScriptingListenerVB.log中\n切记不用时把该插件移除，需要时再复制到Plug-ins目录下，以免撑爆磁盘以及影响ps操作性能。或者使用下载的压缩包里带有两个开关插件的脚本。\n\n上图记录了我打开一张图片，选中它，改变颜色三个步骤的脚步。\n代码实现##遍历所有文本图层ps script中跟图层相关的对象有LayerSet(组)，ArtLayer(图层)，Layer(包括组和图层)。\nfunction getTextLayers(layers)\n&#123;\n\tfor(var i &#x3D; 0, len &#x3D; layers.length; i &lt; len; i++)\n\t&#123;\n\t\tif(layers[i].typename &#x3D;&#x3D; &quot;LayerSet&quot;)\n\t\t&#123;\n\t\t\tgetTextLayers(layers[i].layers)\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tif(layers[i].kind &#x3D;&#x3D; LayerKind.TEXT)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;得到文本图层\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\ngetTextLayers(app.activeDocument.layers);\n\n##文本字号和颜色var text &#x3D; layer.textItem;&#x2F;&#x2F;layer即上文得到的layers[i]\n\nvar color &#x3D; text.color.rgb[&quot;hexValue&quot;];\nvar size &#x3D; text.size.value;\n\n下面代码是怎么从layer获得ActionDescriptor， 需要先将layer设置为目标图层：\napp.activeDocument.activeLayer &#x3D; layer;\n\nfunction char2Type(charId)\n&#123;\n\treturn app.charIDToTypeID(charId);\n&#125;\n\nfunction getActiveLayerDescriptor()\n&#123;\n\tvar ref &#x3D; new ActionReference();\n\tref.putEnumerated(char2Type(&quot;Lyr &quot;), char2Type(&quot;Ordn&quot;), char2Type(&quot;Trgt&quot;));\n\treturn executeActionGet(ref);\n&#125;\n\nvar layerDesc &#x3D; getActiveLayerDescriptor();\n\n##描边&#x2F;投影颜色function getOutline(layerDesc)&#x2F;&#x2F;layerDesc参数即上文通过layer获得的ActionDescriptor类型对象\n&#123;\n\tvar isEffectVisible &#x3D; layerDesc.getVal(&quot;layerFXVisible&quot;);&#x2F;&#x2F;判断图层是否有可见效果\n\tif(!isEffectVisible)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar lfxDesc &#x3D; layerDesc.getVal(&quot;layerEffects&quot;);&#x2F;&#x2F;获得图层效果属性\n\tvar dsDesc &#x3D; lfxDesc ? lfxDesc.getVal(&quot;frameFX&quot;) : null;&#x2F;&#x2F;获得图层描边属性\n\n\t&#x2F;&#x2F;var dsDesc &#x3D; lfxDesc ? lfxDesc.getVal(&quot;dropShadow&quot;) : null;&#x2F;&#x2F;获得图层投影属性\n\n\tif(dsDesc &#x3D;&#x3D; null)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar enable &#x3D; dsDesc.getVal(&quot;enabled&quot;);&#x2F;&#x2F;判断描边&#x2F;投影是否启用\n\tif(!enable)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar rgbTxt &#x3D; descToColorList(dsDesc, &quot;color&quot;);&#x2F;&#x2F;获得图层描边&#x2F;投影颜色\n\treturn changeToHex(rgbTxt);&#x2F;&#x2F;转换成16进制\n&#125;\n\n##渐变颜色function getGradientFill(layerDesc)\n&#123;\n\tvar isEffectVisible &#x3D; layerDesc.getVal(&quot;layerFXVisible&quot;);\n\tif(!isEffectVisible)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar lfxDesc &#x3D; layerDesc.getVal(&quot;layerEffects&quot;);\n\tvar dsDesc &#x3D; lfxDesc ? lfxDesc.getVal(&quot;gradientFill&quot;) : null;\n\tif(dsDesc &#x3D;&#x3D; null)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\tvar enable &#x3D; dsDesc.getVal(&quot;enabled&quot;);\n\tif(!enable)\n\t&#123;\n\t\treturn &quot;&quot;;\n\t&#125;\n\t\n\tvar graDesc &#x3D; dsDesc.getVal(&quot;gradient&quot;);\n\t\n\tvar colorList &#x3D; graDesc.getVal(&quot;colors&quot;, false);&#x2F;&#x2F;ps中可以有多个渐变颜色，unity中一般两个\n\tvar result &#x3D; &quot;&quot;;\n\tfor(s in colorList)\n\t&#123;\n\t\tvar rgbTxt &#x3D; descToColorList(colorList[s], &quot;color&quot;);\n\t\tresult +&#x3D; changeToHex(rgbTxt) + &quot;,&quot;;\n\t&#125;\n\tresult &#x3D; result.substr(0, result.length - 1);\n\treturn result;\n&#125;\n\n##调用方法&#x2F;&#x2F;&#x2F;desc.getVal( keyList );方法的实现，获得desc的属性keyList对应的值\n\nActionDescriptor.prototype.getVal &#x3D; function(keyList, firstListItemOnly)\n&#123;\n\tif (typeof(keyList) &#x3D;&#x3D; &#39;string&#39;)\n\t&#123;\n\t\tkeyList &#x3D; keyList.split(&#39;.&#39;);\n\t&#125;\n\t\t\n\tif (typeof(firstListItemOnly) &#x3D;&#x3D; &quot;undefined&quot;)\n\t&#123;\n\t\tfirstListItemOnly &#x3D; true;\n\t&#125;\n\t\n\tif (keyList.length &#x3D;&#x3D; 0)\n\t&#123;\n\t\treturn this;\n\t&#125;\n\t\n\tkeyStr &#x3D; keyList.shift();\n\tkeyID &#x3D; makeID(keyStr);\n\t\n\tif (this.hasKey(keyID))\n\t&#123;\n\t\tswitch (this.getType(keyID))\n\t\t&#123;\n\t\t\tcase DescValueType.OBJECTTYPE:&#x2F;&#x2F;属性类型为Object\n\t\t\t&#123;\n\t\t\t\treturn this.getObjectValue(keyID).getVal(keyList, firstListItemOnly);\n\t\t\t&#125;\n\t\t\tcase DescValueType.LISTTYPE:&#x2F;&#x2F;属性类型为列表\n\t\t\t&#123;\n\t\t\t\tvar list &#x3D; this.getList(keyID); \n\t\t\t\treturn list.getVal(keyList, firstListItemOnly);\n\t\t\t&#125;\t\n\t\t\tdefault: \n\t\t\t&#123;\n\t\t\t\treturn this.getFlatType(keyID);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\t\n\telse\n\t&#123;\n\t\treturn null;\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;&#x2F;将charID或stringID转换成TypeID\n\ncharID、string相当于底层定义的属性枚举\n\nfunction makeID(keyStr)\n&#123;\n\tif (keyStr[0] &#x3D;&#x3D; &quot;&#39;&quot;)\n\t&#123;\n\t\treturn app.charIDToTypeID(keyStr);\n\t&#125;\n\telse\n\t&#123;\n\t\treturn app.stringIDToTypeID(keyStr);\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;&#x2F;根据不同类型获得最终的值\n\nfunction getFlatType(desc, ID)\n&#123;\n\tswitch (desc.getType(ID))\n\t&#123;\n\t\tcase DescValueType.BOOLEANTYPE:\t\treturn desc.getBoolean(ID);\n\t\tcase DescValueType.STRINGTYPE:\t\treturn desc.getString(ID);\n\t\tcase DescValueType.INTEGERTYPE:\t\treturn desc.getInteger(ID);\n\t\tcase DescValueType.DOUBLETYPE:\t\treturn desc.getDouble(ID);\n\t\tcase DescValueType.UNITDOUBLE:\t\treturn getPSUnitValue(desc, ID);\n\t\tcase DescValueType.ENUMERATEDTYPE: \treturn typeIDToStringID(desc.getEnumerationValue(ID));\n\t\tcase DescValueType.REFERENCETYPE: \treturn getReference(desc.getReference(ID));\n\t\tdefault: \t\t\t\treturn desc.getType(ID).toString();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;&#x2F;获得颜色rgb值\n\nfunction descToColorList(colorDesc, colorPath)\n&#123;\n\tvar i, rgb &#x3D; [&quot;&#39;Rd  &#39;&quot;, &quot;&#39;Grn &#39;&quot;,&quot;&#39;Bl  &#39;&quot;];\n\tvar rgbTxt &#x3D; [];\n\t\n\tcolorDesc &#x3D; colorDesc.getVal(colorPath);\n\tif (!colorDesc)\n\t&#123;\n\t\treturn null;\n\t&#125;\n\n\tfor (i in rgb)\n\t&#123;\n\t\trgbTxt.push( roundColor(colorDesc.getVal(rgb[i])));\n\t&#125;\n\treturn rgbTxt;\n&#125;\n\n&#x2F;&#x2F;&#x2F;转换成16进制颜色值\n\nfunction changeToHex(rgbTxt)\n&#123;\n\tvar value &#x3D; &quot;&quot;;\n\tfor(var i &#x3D; 0, len &#x3D; rgbTxt.length; i &lt; len; i++)\n\t&#123;\n\t\tvar string &#x3D; rgbTxt[i].toString(16);\n\t\tif(string.length &lt; 2)\n\t\t&#123;\n\t\t\tstring &#x3D; &quot;0&quot; + string;\n\t\t&#125;\n\t\tvalue +&#x3D; string;\n\t&#125;\n\treturn value;\n&#125;\n\n运行将代码保存为.jsx后缀文件，放在ps安装目录\\Presets\\Scripts\\下\n运行路径：ps中文件-脚本-.jsx\n运行结果图\n运行前：\n  \n运行后：\n  \n以上就是ps脚本解析psd中文本图层的描边、投影、渐变等属性的主要代码，文本还有许多其它属性，不过unity项目中基本不用。\n完整的脚本在github:https://github.com/503913873/PhotoshopTextParse\n该脚本写得比较早，脚本中一些方法写得比较繁琐，例如遍历图层是用ActionManager方式，没有文中采用DOM方式来得简洁易懂，\ngithub里第二个脚本就是文中的方式。\n貌似ps不同版本的代码也有些差异，该脚本在cs5、cs6中都运行过，基本都可以用，小概率会出现解析的文本字号带小数。\n更详细的语法可以在Adobe官网上查看：http://www.adobe.com/devnet/photoshop/scripting.html\n文笔不好，又是第一次写，写了好多天，ps script研究得也不深，基本是需要什么功能才去搜索，欢迎大家一起讨论学习。\n","slug":"脚本解析photoshop文本属性","date":"2017-09-23T10:35:11.000Z","categories_index":"PhotoShop","tags_index":"photoshop script ps script actionmanager","author_index":"GodwinTsai"},{"id":"3a0b1b76fc538b21ccd4834c8f7647d5","title":"Unity动画优化:Optimize Game Objects","content":"\n\n一、Optimize Game Objects介绍Unity中FBX的导入设置,Inspector中Rig页签下有Optimize Game Objects选项，Unity官方文档的解释是：In the GameObjects hierarchy of a character, the GameObjects which only contain Transform component, will be optimized out unless they are specified in extraExposedTransformPaths for better CPU performance. The remaining GameObjects hierarchy will be flattened.\n当勾选了该选项后，FBX中的骨骼节点，如果只有Transform组件，会被剔除不导入，如果需要某些骨骼节点不被剔除，例如需要挂点，则需要在Extra Transform Paths中勾选对应的骨骼名称。注意：不剔除的节点会被移到根节点之下，因此代码中不能通过原有路径查找（transform.Find(“Bip001&#x2F;Bip001 Spine”)）。\n原理：Remove and store the GameObject Transform hierarchy of the imported character in the Avatar and Animator component. If enabled, the SkinnedMeshRenderers of the character use the Unity animation system’s internal skeleton, which improves the performance of the animated characters.Only available if the Avatar Definition is set to Create From This Model.\nUnity会将骨骼信息映射到avatar中，这样，unity在更新骨骼矩阵时，不再考虑场景中的Transform节点，也不用更新它的坐标，而是直接通过获取avatar骨骼信息来更新蒙皮，表现动画，从而节省了cpu计算。\n二、优化前后对比优化前模型结构：优化后模型结构：Animator.hasTransformHierarchy会变为falseSkinMeshRender.rootBone会变为空\n三、代码对应接口：\nAnimatorUtility.DeoptimizeTransformHierarchy(GameObject go);\nAnimatorUtility.OptimizeTransformHierarchy(GameObject go, string[] exposedTransforms)\n\n不过我们项目是把fbx内嵌在模型prefab中，使用该接口会报错：因此改用修改ModelImporter的方式。另外我们会有些虚拟挂载点绑定在骨骼下。因此需要在编辑挂载点前显示所有骨骼，编辑好后优化剔除无用的骨骼。\n取消优化：\npublic static void UndoOptimize(GameObject root)\n        &#123;\n            var animator &#x3D; root.GetComponentInChildren&lt;Animator&gt;();&#x2F;&#x2F;Animator组件挂在fbx节点上\n            if (animator &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n\n            var fbxGo &#x3D; animator.gameObject;\n            var fbxPath &#x3D; AssetDatabase.GetAssetPath(PrefabUtility.GetCorrespondingObjectFromSource(fbxGo));&#x2F;&#x2F;获取fbx在Project中的路径\n            \n            var importer &#x3D; AssetImporter.GetAtPath(fbxPath) as ModelImporter;\n            if (importer &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n            importer.optimizeGameObjects &#x3D; false;\n            importer.SaveAndReimport();\n        &#125;\n\n优化：\npublic static void Optimize(GameObject root)\n        &#123;\n            var animator &#x3D; root.GetComponentInChildren&lt;Animator&gt;();\n            if (animator &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n\n            var fbxGo &#x3D; animator.gameObject;\n            var dummys &#x3D; root.GetComponentsInChildren&lt;DummyData&gt;();&#x2F;&#x2F;自定义的虚拟挂载点\n            List&lt;string&gt; exposedTransNameList &#x3D; new List&lt;string&gt;();\n            foreach (var dummy in dummys)\n            &#123;\n                if (dummy.Parent !&#x3D; null &amp;&amp; dummy.Parent !&#x3D; dummy.Root)&#x2F;&#x2F;筛选绑在骨骼上的挂载点\n                &#123;\n                    var fullPath &#x3D; AnimationUtility.CalculateTransformPath(dummy.Parent.transform, fbxGo.transform);&#x2F;&#x2F;获取骨骼的完整路径\n                    exposedTransNameList.Add(fullPath);\n                &#125;\n            &#125;\n            \n            var fbxPath &#x3D; AssetDatabase.GetAssetPath(PrefabUtility.GetCorrespondingObjectFromSource(fbxGo));\n            var importer &#x3D; AssetImporter.GetAtPath(fbxPath) as ModelImporter;\n            if (importer &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n            importer.optimizeGameObjects &#x3D; true;\n            importer.extraExposedTransformPaths &#x3D; exposedTransNameList.ToArray();\n            importer.SaveAndReimport();\n        &#125;\n\n优化后可以看到fbx meta文件变化：\n","slug":"Unity动画优化!Optimize Game Objects","date":"2020-03-12T06:43:16.000Z","categories_index":"Unity Optimize","tags_index":"","author_index":"GodwinTsai"},{"id":"d0e1bfe93c0db1f072a3c290822ee8c7","title":"bilibili发送弹幕","content":"\n\n前言媳妇儿玩起了bilibili直播，我就顺便研究下利用python发送弹幕，以表支持～，主要思路通过发送http请求。\n发送弹幕1. 查询http请求首先登录b站，进入直播间，打开开发者工具，先在直播间发送一条弹幕。\n可以看到请求的url地址，请求方式是post，以及请求的表单数据：\n2. 查询自己账号cookie和user-agent信息打开开发者工具，进入个人中心&#x2F;首页：\n3. 代码\nimport requests\nimport time\n\nclass bullet_screen():\n    def __init__(self, room_id):\n        self.room_id &#x3D; room_id\n        self.send_url &#x3D; &quot;https:&#x2F;&#x2F;api.live.bilibili.com&#x2F;msg&#x2F;send&quot;\n        self.cookie &#x3D; &#123;&#39;Cookie&#39; : &#39;填入上图查询到的cookie&#39;&#125;\n        self.header &#x3D; &#123;&#39;User-Agent&#39; : &#39;填入上图查询到的userAgent&#39;&#125;\n\n        self.send_data &#x3D; &#123;\n            &#39;color&#39;: 16777215,\n            &#39;fontsize&#39;: 25,\n            &#39;mode&#39;: 1,\n            &#39;msg&#39;: &#39;123&#39;,\n            &#39;rnd&#39;: 1582471255,\n            &#39;roomid&#39;: room_id,\n            &#39;bubble&#39;: 0,\n            &#39;csrf_token&#39;: &#39;44d0e7f3eaea7ff05774822e8eaf49b2&#39;,\n            &#39;csrf&#39;: &#39;44d0e7f3eaea7ff05774822e8eaf49b2&#39;\n        &#125;\n\n    def send(self, msg):\n        self.send_data[&#39;rnd&#39;] &#x3D; time.time() #获得当前的时间戳\n        self.send_data[&#39;msg&#39;] &#x3D; msg\n        reponse &#x3D; requests.post(self.send_url, data&#x3D;self.send_data,cookies&#x3D;self.cookie,headers&#x3D;self.header)\n        return reponse\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    bullet_screen &#x3D; bullet_screen(21912783)\n    response &#x3D; bullet_screen.send(&#39;棒棒哒&#39;)\n    print(response)\n\n查询弹幕1. 查询http请求打开开发者工具，刷新下页面，找到一个msg信息，可以得到路径和表单信息：\n2. 查询返回信息结构在Preview 标签中可以看到返回了最后10条弹幕：\n3. 代码\nimport requests\nimport json\n\nclass bullet_screen():\n    def __init__(self, room_id):\n        self.room_id &#x3D; room_id\n        self.query_url &#x3D; &#39;https:&#x2F;&#x2F;api.live.bilibili.com&#x2F;ajax&#x2F;msg&#39;\n        self.cookie &#x3D; &#123;&#39;Cookie&#39; : &#39;填入上图查询到的cookie&#39;&#125;\n        self.header &#x3D; &#123;&#39;User-Agent&#39; : &#39;填入上图查询到的userAgent&#39;&#125;\n\n        self.query_data &#x3D; &#123;\n            &#39;roomid&#39;: room_id,\n            &#39;csrf_token&#39;: &#39;44d0e7f3eaea7ff05774822e8eaf49b2&#39;,\n        &#125;\n\n    def query(self):\n        response &#x3D; requests.post(self.query_url, data &#x3D; self.query_data)\n        rooms &#x3D; response.json()[&#39;data&#39;][&#39;room&#39;]\n        count &#x3D; len(rooms)\n        if count &gt; 0:\n            return rooms[count - 1][&#39;text&#39;]\n        return None\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    bullet_screen &#x3D; bullet_screen(21912783)\n    response &#x3D; bullet_screen.query()\n    # bullet_screen.send(response)\n    print(response)\n\n获得最近一条弹幕，这样就可以跟着发送相同弹幕了\n自动聊天弹幕网上有个图灵机器人，可以实现人机对话，挺有趣，利用它来发送弹幕内容。\n1. 注册首先到图灵机器人注册，创建机器人，得到一个32位的key。\n2，http请求请求接口为http://openapi.tuling123.com/openapi/api/v2，方式为post，请求参数为如下json格式：\n\n&#123;\n    &quot;reqType&quot;:0,\n    &quot;perception&quot;: &#123;\n        &quot;inputText&quot;: &#123;\n            &quot;text&quot;: &quot;附近的酒店&quot;\n        &#125;,\n        &quot;inputImage&quot;: &#123;\n            &quot;url&quot;: &quot;imageUrl&quot;\n        &#125;,\n        &quot;selfInfo&quot;: &#123;\n            &quot;location&quot;: &#123;\n                &quot;city&quot;: &quot;北京&quot;,\n                &quot;province&quot;: &quot;北京&quot;,\n                &quot;street&quot;: &quot;信息路&quot;\n            &#125;\n        &#125;\n    &#125;,\n    &quot;userInfo&quot;: &#123;\n        &quot;apiKey&quot;: &quot;&quot;,\n        &quot;userId&quot;: &quot;&quot;\n    &#125;\n&#125;\n\n\n3. 返回格式&#123;\n    &quot;intent&quot;: &#123;\n        &quot;code&quot;: 10005,\n        &quot;intentName&quot;: &quot;&quot;,\n        &quot;actionName&quot;: &quot;&quot;,\n        &quot;parameters&quot;: &#123;\n            &quot;nearby_place&quot;: &quot;酒店&quot;\n        &#125;\n    &#125;,\n    &quot;results&quot;: [\n        &#123;\n         \t&quot;groupType&quot;: 1,\n            &quot;resultType&quot;: &quot;url&quot;,\n            &quot;values&quot;: &#123;\n                &quot;url&quot;: &quot;http:&#x2F;&#x2F;m.elong.com&#x2F;hotel&#x2F;0101&#x2F;nlist&#x2F;#indate&#x3D;2016-12-10&amp;outdate&#x3D;2016-12-11&amp;keywords&#x3D;%E4%BF%A1%E6%81%AF%E8%B7%AF&quot;\n            &#125;\n        &#125;,\n        &#123;\n         \t&quot;groupType&quot;: 1,\n            &quot;resultType&quot;: &quot;text&quot;,\n            &quot;values&quot;: &#123;\n                &quot;text&quot;: &quot;亲，已帮你找到相关酒店信息&quot;\n            &#125;\n        &#125;\n    ]\n&#125;\n\n4. 代码\nimport requests\nimport json\n\nclass bullet_screen():\n    def __init__(self, room_id):\n        self.room_id &#x3D; room_id\n        self.api_key &#x3D; &#39;&#39;# 填注册后获得的32位key\n        self.user_id &#x3D; &#39;9527&#39;#随便填\n\n    def get_robot_dialogue(self, msg):\n        api_url &#x3D; &#39;http:&#x2F;&#x2F;openapi.tuling123.com&#x2F;openapi&#x2F;api&#x2F;v2&#39;\n        req &#x3D; &#123;\n            &#39;reqType&#39;: 0,\n            &#39;perception&#39;: &#123;\n                &#39;inputText&#39;: &#123;\n                    &#39;text&#39;: msg\n                &#125;\n            &#125;,\n            &#39;userInfo&#39;: &#123;\n                &#39;apiKey&#39;: self.api_key,\n                &#39;userId&#39;: self.user_id\n            &#125;\n        &#125;\n        req &#x3D; json.dumps(req).encode(&#39;utf8&#39;)\n        response &#x3D; requests.post(api_url, data&#x3D;req, headers&#x3D;&#123;&#39;content-type&#39;: &#39;application&#x2F;json&#39;&#125;)\n        response_dic &#x3D; response.json()\n        intent_code &#x3D; response_dic[&#39;intent&#39;][&#39;code&#39;]\n        results_text &#x3D; response_dic[&#39;results&#39;][0][&#39;values&#39;][&#39;text&#39;]\n        return intent_code, results_text\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    bullet_screen &#x3D; bullet_screen(21912783)\n    code,text &#x3D; bullet_screen.get_robot_dialogue(&#39;主播棒棒哒&#39;)\n    print(code,text)\n\n\n效果现在可以根据最新一条弹幕内容，发送自动对话的结果了\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    bullet_screen &#x3D; bullet_screen(21912783)\n    lastMsg &#x3D; bullet_screen.query()\n    code, dialogue &#x3D; bullet_screen.get_robot_dialogue(lastMsg)\n    if code &#x3D;&#x3D; 0:\n        response &#x3D; bullet_screen.send(dialogue)\n    print(lastMsg,dialogue)\n\n效果如下：\n图灵机器人没有验证或者购买的话，只有3次免费试用机会，笑哭\n","slug":"bilibili发送弹幕","date":"2020-02-23T17:51:40.000Z","categories_index":"Python","tags_index":"","author_index":"GodwinTsai"},{"id":"cf6a4766c3507937614ad6819b2f17d9","title":"批量删除预制脚本","content":"\n\n环境：Unity 2018.4.12需求：项目中经常需要在Unity Editor模式下批量删除Prefab中的某个脚本，但是直接用&#96;GameObject.DestroyImmediate(obj);&#96;会报错：Destroying assets is not permitted to avoid data loss.解决方法是通过&#96;SerializedProperty.DeleteArrayElementAtIndex(i)&#96;。\n\n代码：private bool RemoveComponents(Component[] components)\n        &#123;\n            if (components.Length &#x3D;&#x3D; 0)\n            &#123;\n                return false;\n            &#125;\n            foreach (var component in components)\n            &#123;\n                SerializedObject so &#x3D; new SerializedObject(component.gameObject);\n                SerializedProperty sp &#x3D; so.FindProperty(&quot;m_Component&quot;);\n\n                var allComponents &#x3D; component.gameObject.GetComponents&lt;Component&gt;();\n                for (int i &#x3D; 0, len &#x3D; allComponents.Length; i &lt; len; i++)\n                &#123;\n                    if (allComponents[i] &#x3D;&#x3D; component)\n                    &#123;\n                        sp.DeleteArrayElementAtIndex(i);\n                        so.ApplyModifiedProperties();\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n\n            return true;\n        &#125;\n\npublic  bool RemoveComponents&lt;T&gt;(GameObject root) where T : Component\n        &#123;\n            if (root &#x3D;&#x3D; null)\n            &#123;\n                return false;\n            &#125;\n            var components &#x3D; root.GetComponentsInChildren&lt;T&gt;(true);\n            return RemoveComponents(components);\n        &#125;\n\n工具为了方便使用，实现一个EditorWindow来操作，代码如下：\n\nusing UnityEditor;\nusing UnityEngine;\n\nnamespace Common.Editor.Common\n&#123;\n    public class RemoveComponentEditor : EditorWindow\n    &#123;\n        private static RemoveComponentEditor _instance;\n        private static string[] _selectAssets;\n        private static string _key;\n        private static MonoScript _monoScript;\n        \n        [MenuItem(&quot;PrefabTool&#x2F;RemoveComponentEditor&quot;)]\n        public static void ShowWindow()\n        &#123;\n            _instance &#x3D; GetWindow(typeof(RemoveComponentEditor)) as RemoveComponentEditor;\n            _instance.Show();\n        &#125;\n        \n        void OnGUI()\n        &#123;\n            _selectAssets &#x3D; Selection.assetGUIDs;\n            if (_selectAssets &#x3D;&#x3D; null || _selectAssets.Length &#x3D;&#x3D; 0)\n            &#123;\n                EditorGUILayout.LabelField(&quot;No Assets Selected&quot;);\n            &#125;\n            else\n            &#123;\n                EditorGUILayout.LabelField($&quot;Selected Assets：\\n&quot;);\n                foreach (var asset in _selectAssets)\n                &#123;\n                    var path &#x3D; AssetDatabase.GUIDToAssetPath(asset);\n                    EditorGUILayout.LabelField($&quot;&#123;path&#125;\\n&quot;);\n                &#125;\n            &#125;\n\n            _key &#x3D; EditorGUILayout.TextField(&quot;Prefab Name Key:&quot;, _key);\n            _monoScript &#x3D; EditorGUILayout.ObjectField(&quot;Script&quot;, _monoScript, typeof(MonoScript), false) as MonoScript;\n            if (GUILayout.Button(&quot;Remove&quot;))\n            &#123;\n                Remove();\n            &#125;\n        &#125;\n\n        private void Remove()\n        &#123;\n            if (_selectAssets &#x3D;&#x3D; null || _selectAssets.Length &#x3D;&#x3D; 0)\n            &#123;\n                EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please Select A Folder Or Asset&quot;, &quot;OK&quot;);\n                return;\n            &#125;\n\n            if (_monoScript &#x3D;&#x3D; null)\n            &#123;\n                EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please Select A Mono Script&quot;, &quot;OK&quot;);\n                return;\n            &#125;\n\n            var prefabs &#x3D; CommonToolUtil.GetSelectPrefabs(_key);\n            CommonToolUtil.ExecutePrefabs(prefabs, Execute, &quot;Execute&quot;, true);\n        &#125;\n        \n        private bool Execute(GameObject prefab)\n        &#123;\n            return CommonToolUtil.RemoveComponents(prefab, _monoScript);\n        &#125;\n    &#125;\n&#125;\n\nGetSelectPrefabs()函数用来获得选中目录下的所有Prefabs,参数key用来过滤Prefab的名字，因为一个文件夹下可能有多个采用不同前后缀命名的Variant：\npublic static List&lt;GameObject&gt; GetSelectPrefabs(string key)\n        &#123;\n            List&lt;GameObject&gt; list &#x3D; new List&lt;GameObject&gt;();\n            Object[] selectedAssets &#x3D; Selection.GetFiltered(typeof(Object), SelectionMode.DeepAssets);\n            foreach (Object asset in selectedAssets)\n            &#123;\n                string filePath &#x3D; AssetDatabase.GetAssetPath(asset);\n                if (!filePath.EndsWith(&quot;.prefab&quot;))\n                &#123;\n                    continue;\n                &#125;\n\n                if (!string.IsNullOrEmpty(key))\n                &#123;\n                    var fileName &#x3D; Path.GetFileNameWithoutExtension(filePath);\n                    if (!fileName.Contains(key))\n                    &#123;\n                        continue;\n                    &#125;\n                &#125;\n                \n                var prefab &#x3D; AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(filePath);\n                if (prefab &#x3D;&#x3D; null)\n                &#123;\n                    continue;\n                &#125;\n                list.Add(prefab);\n            &#125;\n            return list;\n        &#125;\n\nExecutePrefabs函数遍历Prefabs，并显示进度条，有修改则保存\npublic static void ExecutePrefabs(List&lt;GameObject&gt; prefabs, Func&lt;GameObject, bool&gt; action, string content, bool save &#x3D; true)\n        &#123;\n            var count &#x3D; prefabs.Count;\n            var index &#x3D; 0;\n            foreach (var prefab in prefabs)\n            &#123;\n                EditorUtility.DisplayProgressBar(content,\n                    $&quot;&#123;content&#125;...&#123;++index&#125;&#x2F;&#123;count&#125;&quot;, (float) index &#x2F; count);\n                bool result &#x3D; action.Invoke(prefab);\n                if (save &amp;&amp; result)\n                &#123;\n                    PrefabUtility.SavePrefabAsset(prefab);\n                &#125;\n            &#125;\n\n            if (save)\n            &#123;\n                AssetDatabase.SaveAssets();\n                AssetDatabase.Refresh();\n            &#125;\n            \n            EditorUtility.ClearProgressBar();\n        &#125;\n\nRemoveComponents函数通过MonoScript获得Component数组，调用上面的方法移除组件\npublic static bool RemoveComponents(GameObject root, MonoScript monoScript)\n        &#123;\n            if (root &#x3D;&#x3D; null || monoScript &#x3D;&#x3D; null)\n            &#123;\n                return false;\n            &#125;\n\n            var type &#x3D; monoScript.GetClass();\n            if (type &#x3D;&#x3D; null)\n            &#123;\n                return false;\n            &#125;\n\n            var components &#x3D; root.GetComponentsInChildren(type);\n            return RemoveComponents(components);\n        &#125;\n\n运行效果如图：可以选择目录或预制，设置关键词过滤，选择要删除的组件\n","slug":"批量删除预制脚本","date":"2020-01-02T16:54:06.000Z","categories_index":"Unity","tags_index":"","author_index":"GodwinTsai"},{"id":"278122282ab7fc90233764072d390801","title":"Timeline Note--引用无关资源","content":"\n\n一，环境：Unity 2018.4.2\n二，结构一个Prefab一段Timeline演出，Prefab上会挂PlayableDirector组件，并绑定Timeline Asset。Timeline Asset的编辑内容\n三，现象对预制执行Select Dependencies发现：该预制额外地引用了一些无关的资源，例如两个FBX资源，动作（skill2_x），甚至还引用了其它的Timeline Asset（4110092，BossShow）。\n四，分析1，通过查看prefab和meta文件：发现PlayableDirector的m_SceneBindings有很多guid的引用。但由图1、图2可见Timeline Asset中其实只有8个绑定。2，选择Inspector的Debug模式发现竟然有28个绑定。3，经测试发现，复制Prefab时，PlayableDirector组件的Binding也会跟着复制，即使关联新的TimelineAsset，也不会清空重新赋值，估计Unity后面版本会修复。\n五，解决PlayableDirector组件的Binding字段是写在c++，也没有提供访问或清空的接口。因此采用重挂组件再赋值的办法。\npublic static void OptimizeBinding(GameObject go)\n&#123;\n    var prefab &#x3D; GameObject.Instantiate(go);\n    var director &#x3D; prefab.GetComponent&lt;PlayableDirector&gt;();\n    if (director &#x3D;&#x3D; null)\n    &#123;\n        return;\n    &#125;\n    var timelineAsset &#x3D; director.playableAsset as TimelineAsset;\n    if (timelineAsset &#x3D;&#x3D; null)\n    &#123;\n        return;\n    &#125;\n    Dictionary&lt;UnityEngine.Object, UnityEngine.Object&gt; bindings &#x3D; new Dictionary&lt;UnityEngine.Object, UnityEngine.Object&gt;();\n    foreach (var pb in director.playableAsset.outputs)\n    &#123;\n        var key &#x3D; pb.sourceObject;\n        var value &#x3D; director.GetGenericBinding(key);\n        if (!bindings.ContainsKey(key))\n        &#123;\n            bindings.Add(key, value);\n        &#125;\n    &#125;\n    \n    GameObject.DestroyImmediate(director);\n    director &#x3D; prefab.AddComponent&lt;PlayableDirector&gt;();\n    director.playableAsset &#x3D; timelineAsset;\n    director.playOnAwake &#x3D; false;\n    foreach (var pair in bindings)\n    &#123;\n        director.SetGenericBinding(pair.Key, pair.Value);\n    &#125;\n    var path &#x3D; AssetDatabase.GetAssetPath(go);\n    PrefabUtility.SaveAsPrefabAsset(prefab, path, out var success);\n    GameObject.DestroyImmediate(prefab);\n&#125;\n\n六，结果运行脚本后，Prefab不再引用不相关的资源，PlayableDirector的Binding数量也跟TimelineAsset的Track数量一致。\n","slug":"Timeline Note--引用无关资源","date":"2019-08-21T04:09:46.000Z","categories_index":"Timeline","tags_index":"Timeline 坑 资源引用 资源依赖","author_index":"GodwinTsai"},{"id":"077ece2c7670b51ed3e04645fca4119e","title":"Timeline 一，简介","content":"\n\n尊重原创，转载请在文首注明出处：https://blog.csdn.net/cai612781/article/details/99330696\n环境：\nUnity 2018.4\n \n一，Introduction\n1.1,Timeline\nTimeline是Unity2017新增的一个用于方便组织场景动画的工具，可用来制作剧情动画、技能演出等，还可配合Cinemachine做运镜。\n1.2,,Timeline Asset\nTimeline在Unity中是一种Asset资源文件，通过Asset&#x2F;Create&#x2F;Timeline菜单创建。\n\n \n \n \n1.3,Playable Director Component\nPlayableDirector是用来播放Timeline Asset的组件。\n\n \n1.4 Playable Graph\n编辑好的一个Timeline Asset，在播放时，会创建成一个Playable Graph，Playable Graph相当于Timeline Asset的一个实例，因此一个Timeline Asset可以被多个Playable Directory同时播放，互不干扰。\n \n二，Using Timeline\n2.1,Timeline Editor\n双击Timeline Asset，或Window&#x2F;Timeline Editor菜单可打开Timeline编辑器。\n\n \nOfficial Track &amp; Group:\n2.1.1 TrackGroup\n分组的概念\n2.1.2 Activation Track\n显示&#x2F;隐藏\n2.1.3 Animation Track\n播放动作\n2.1.4 Audio Track\n播放音效\n2.1.5 Control Track\n控制GameObject，粒子特效，嵌套Playable Directory\n2.1.6 Playable Track\n脚本\n2.1.7 Signal Track\nUnity 2019才有的功能，用于发送信号，类似关键帧\n2.1.8 Cinemachine Track\n安装Cinemachine Package后，可控制虚拟相机做运镜\n \n2.2 Clips\n\n \n每条轨道(track)上，可以创建多个对应的clip，clip上关联资源或者数据.\n当两个clip重叠时，重叠区域会进行融合。\n\n \n每个clip上都会有开始、结束、持续的时间配置，对应在轨道上的位置和长度。\n\n \n可融合的clip，例如Animation Clip还显示融合的参数配置\n\n \nPre-Extrapolate和Post-Extrapolate：分别代表clip前后的空白间隙如何表现：\nHold：保持在最接近clip的一帧状态；\nLoop：循环播放clip；\nPingPong:前向和后向循环播放；\nContinue:根据动画原始资源设置的循环模式播放；\n \n \n \n2.3,Recording and Editing Animation\n\n \nAnimation Track有个红点，支持录制一段Animation动画。\n录制的动画可以有infinite track和clip tracks两种形态。\n","slug":"Timeline 一，简介","date":"2019-08-12T12:00:51.000Z","categories_index":"Timeline","tags_index":"Timeline","author_index":"GodwinTsai"},{"id":"3e1482db617d1778a858877ea039d577","title":"ps脚本解析psd文本字号","content":"\n\nps脚本解析psd中文本字号最简单的方法，通过DOM获取：var size &#x3D; activeDocument.activeLayer.textItem.size;  \n但是当该文本被拉伸过后，DOM解析出来的字号就会错误。正确的方式是通过Action Manager来获取：\nfunction getTextSize()&#123;  \n    var ref &#x3D; new ActionReference();  \n    ref.putEnumerated( charIDToTypeID(&quot;Lyr &quot;), charIDToTypeID(&quot;Ordn&quot;), charIDToTypeID(&quot;Trgt&quot;) );   \n    var desc &#x3D; executeActionGet(ref).getObjectValue(stringIDToTypeID(&#39;textKey&#39;));  \n    var textSize &#x3D;  desc.getList(stringIDToTypeID(&#39;textStyleRange&#39;)).getObjectValue(0).getObjectValue(stringIDToTypeID(&#39;textStyle&#39;)).getDouble (stringIDToTypeID(&#39;size&#39;));  \n    if (desc.hasKey(stringIDToTypeID(&#39;transform&#39;))) \n    &#123;  \n            var mFactor &#x3D; desc.getObjectValue(stringIDToTypeID(&#39;transform&#39;)).getUnitDoubleValue (stringIDToTypeID(&quot;yy&quot;) );  \n            textSize &#x3D; (textSize* mFactor).toFixed(0);  \n    &#125;  \n    return textSize;  \n&#125; ","slug":"ps脚本解析psd文本字号","date":"2018-08-25T06:59:52.000Z","categories_index":"PhotoShop","tags_index":"","author_index":"GodwinTsai"},{"id":"352e398b9e08d481e8318632bbc69c42","title":"C#调用可执行文件","content":"\n\n尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/79030654\n一，语法\nC#提供Process类来对本地或远程进程进行访问，以及启动或停止本地进程。\n更多语法信息：https://msdn.microsoft.com/zh-cn/library/system.diagnostics.process.aspx\n二，代码\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing Debug &#x3D; UnityEngine.Debug;\n\nnamespace Assets.Editor\n&#123;\n    public class EditorUtil\n    &#123;\n        public static void ExecuteProcess(string filePath, string command, string workPath &#x3D; &quot;&quot;, int seconds &#x3D; 0)\n        &#123;\n            if (string.IsNullOrEmpty(filePath))\n            &#123;\n                return;\n            &#125;\n            Process process &#x3D; new Process();&#x2F;&#x2F;创建进程对象\n            process.StartInfo.WorkingDirectory &#x3D; workPath;\n            process.StartInfo.FileName &#x3D; filePath;\n            process.StartInfo.Arguments &#x3D; command;\n            process.StartInfo.CreateNoWindow &#x3D; true;\n            process.StartInfo.RedirectStandardOutput &#x3D; false;&#x2F;&#x2F;不重定向输出\n            try\n            &#123;\n                if (process.Start())\n                &#123;\n                    if (seconds &#x3D;&#x3D; 0)\n                    &#123;\n                        process.WaitForExit(); &#x2F;&#x2F;无限等待进程结束\n                    &#125;\n                    else\n                    &#123;\n                        process.WaitForExit(seconds); &#x2F;&#x2F;等待毫秒\n                    &#125;\n                &#125;\n            &#125;\n            catch (Exception e)\n            &#123;\n                Debug.LogError(e.Message);\n            &#125;\n            finally\n            &#123;\n                process.Close();\n            &#125;\n        &#125;\n    &#125;\n&#125;","slug":"CSharp调用可执行文件","date":"2018-01-11T01:50:59.000Z","categories_index":"C#","tags_index":"C#启动进程 C#调用可执行文件","author_index":"GodwinTsai"},{"id":"753f4a58196ae7671f17e65f13baa6b7","title":"C#复制文件","content":"\n\n尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/79015286\n开发Unity编辑器工具中经常遇到需要把文件复制到工程中，例如数据、图片等。\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace Assets.Editor\n&#123;\n\tclass FileUtil\n\t&#123;\n\t\t&#x2F;&#x2F;比较两个文件夹，获得改动的文件\n\t\tpublic static FileInfo[] GetNeedCopyFiles(string srcPath, string desPath, bool forceCopy &#x3D; false)\n\t\t&#123;\n\t\t\tFileInfo[] files &#x3D; &#123;&#125;;\n\t\t\tList&lt;FileInfo&gt; fileInfoList &#x3D; new List&lt;FileInfo&gt;();\n\t\t\tDirectoryInfo srcDirInfo &#x3D; new DirectoryInfo(srcPath);\n\t\t\tDirectoryInfo desDirInfo &#x3D; new DirectoryInfo(desPath);\n\t\t\tif(!srcDirInfo.Exists)\n\t\t\t&#123;\n\t\t\t\treturn files;\n\t\t\t&#125;\n\t\t\tif(!desDirInfo.Exists)\n\t\t\t&#123;\n\t\t\t\tDirectory.CreateDirectory(desPath);\n\t\t\t&#125;\n\t\t\tFileInfo[] fileArr &#x3D; srcDirInfo.GetFiles();\n\t\t\tfor(int i &#x3D; 0, len &#x3D; fileArr.Length; i &lt; len; i++)\n\t\t\t&#123;\n\t\t\t\tstring filePath &#x3D; desDirInfo.FullName + &quot;\\\\&quot; + fileArr[i].Name;\n\t\t\t\tFileInfo fileInfo &#x3D; new FileInfo(filePath);\n\t\t\t\tif(!fileInfo.Exists)\n\t\t\t\t&#123;\n\t\t\t\t\tfileInfoList.Add(fileArr[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t&#125;\n\t\t\t\tif(forceCopy || fileArr[i].Length !&#x3D; fileInfo.Length)\n\t\t\t\t&#123;\n\t\t\t\t\tfileInfoList.Add(fileArr[i]);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tfiles &#x3D; fileInfoList.ToArray();\n\t\t\treturn files;\n\t\t&#125;\n\t\t\n\t\t&#x2F;&#x2F;拷贝文件到目标路径\n\t\tpublic static void CopyFiles(ileInfo[] infos, string desPath)\n\t\t&#123;\n\t\t\tstring desFileName;\n\t\t\tFileInfo file;\n\t\t\tfor(int i &#x3D; 0, len &#x3D; infos.Length; i &lt; len; i++)\n\t\t\t&#123;\n\t\t\t\tfile &#x3D; infos[i];\n\t\t\t\tdesFileName &#x3D; Path.Combine(desPath, file.Name);\n\t\t\t\tif(File.Exists(desFileName))\n\t\t\t\t&#123;\n\t\t\t\t\tnew FileInfo(desFileName).IsReadOnly &#x3D; false;&#x2F;&#x2F;注1\n\t\t\t\t&#125;\n\t\t\t\tfile.CopyTo(desFileName, true);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n注1：\n当删除文件或者复制文件时选择覆盖，如果该文件是个只读文件，则会抛出异常：System.UnauthorizedAccessException。\n解决方法是：\nnew FileInfo(filePath).IsReadOnly &#x3D; false;\n或者：\nnew FileInfo(filePath).Attributes &#x3D; FileAttributes.Normal;\n","slug":"CSharp复制文件","date":"2018-01-09T09:22:12.000Z","categories_index":"C#","tags_index":"C#复制文件 删除只读文件异常","author_index":"GodwinTsai"},{"id":"46fb15b5cb654d863634ab785c7560a1","title":"C#调用SVN","content":"\n\n尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/79015085\n一，语法\n项目开发中通常都会使用Subversion(SVN)作为版本控制系统，同时会使用SVN的客户端软件TortoiseSVN。\n我们通过TortoiseSVN的TortoiseProc.exe程序添加参数，来实现在C#或bat批处理脚本中调用SVN。举个栗子： TortoiseProc.exe &#x2F;command:update &#x2F;path:xxx &#x2F;closeonend:0\n&#x2F;command表示SVN的操作命令\n&#x2F;path表示操作的路径，可以有多个，用*分隔\n&#x2F;closeonend用于在执行完毕后关闭对话框：\n&#x2F;closeonend:0不自动关闭对话框\n&#x2F;closeonend:1没有错误，则自动关闭对话框\n&#x2F;closeonend:2没有错误、冲突，则自动关闭对话框\n&#x2F;closeonend:3没有错误、冲突、合并，自动关闭对话框\n \n二，代码\n \nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\n\nnamespace Assets.Editor.Svn\n&#123;\n    public class SvnUtil : UnityEditor.Editor\n    &#123;\n        private static string _svnPath &#x3D; &quot;&quot;;\n\n        public static void DelAndUpdateSvnFile(string path)\n        &#123;\n            if (File.Exists(path))\n            &#123;\n                File.Delete(path);\n            &#125;\n            ExecuteProcess(GetSvnProcPath(), string.Format(&quot;&#x2F;command:update &#x2F;path:&#123;0&#125; &#x2F;closeonend:2&quot;, path));\n        &#125;\n\n        public static void RevertAndUpdateSvnDirectory(string path)\n        &#123;\n            ExecuteProcess(GetSvnProcPath(), string.Format(&quot;&#x2F;command:revert -r &#x2F;path:&#123;0&#125; &#x2F;closeonend:2&quot;, path));\n            ExecuteProcess(GetSvnProcPath(), string.Format(&quot;&#x2F;command:update &#x2F;path:&#123;0&#125; &#x2F;closeonend:2&quot;, path));\n        &#125;\n\n        public static void UpdateSvnDirectory(string path)\n        &#123;\n            ExecuteProcess(GetSvnProcPath(), string.Format(&quot;&#x2F;command:update &#x2F;path:&#123;0&#125; &#x2F;closeonend:2&quot;, path));\n        &#125;\n\n        public static void CommitSvnDirectory(string path)\n        &#123;\n            ExecuteProcess(GetSvnProcPath(), string.Format(&quot;&#x2F;command:commit &#x2F;path:&#123;0&#125; &#x2F;closeonend:0&quot;, path));\n        &#125;\n\n        public static void ProcessSvnCommand(string command)\n        &#123;\n            ExecuteProcess(GetSvnProcPath(), command);\n        &#125;\n\n        private static List&lt;string&gt; drives &#x3D; new List&lt;string&gt;() &#123; &quot;c:&quot;, &quot;d:&quot;, &quot;e:&quot;, &quot;f:&quot;&#125;;\n\n        private static string svnPath &#x3D; @&quot;\\Program Files\\TortoiseSVN\\bin\\&quot;;\n        private static string svnProc &#x3D; @&quot;TortoiseProc.exe&quot;;\n        private static string svnProcPath &#x3D; &quot;&quot;;\n\n        private static string GetSvnProcPath()\n        &#123;\n            if (_svnPath !&#x3D; string.Empty)\n            &#123;\n                return _svnPath;\n            &#125;\n            foreach (string item in drives)\n            &#123;\n                string path &#x3D; string.Concat(item, svnPath, svnProc);\n                if (File.Exists(path))\n                &#123;\n                    _svnPath &#x3D; path;\n                    break;\n                &#125;\n            &#125;\n            if (_svnPath &#x3D;&#x3D; string.Empty)\n            &#123;\n                _svnPath &#x3D; EditorUtility.OpenFilePanel(&quot;Select TortoiseProc.exe&quot;, &quot;c:\\\\&quot;, &quot;exe&quot;);\n            &#125;\n\t\t\t&#x2F;&#x2F;可将路径存到本地注册表\n            return _svnPath;\n        &#125;\n\n        private static void ExecuteProcess(string filePath, string command, int seconds &#x3D; 0)\n        &#123;\n            EditorUtil.ExecuteProcess(filePath, command, &quot;&quot;, seconds);&#x2F;&#x2F;参见文末另一篇：C#调用可执行文件\n        &#125;\n    &#125;\n&#125;\n\nEditorUtil.ExecuteProcess 参见另一篇：C#调用可执行文件\n","slug":"CSharp调用SVN","date":"2018-01-09T09:10:37.000Z","categories_index":"C#","tags_index":"C#调用SVN","author_index":"GodwinTsai"},{"id":"21ad9801a0836d599aef927bc9336390","title":"Unity协程&在编辑器中使用协程","content":"\n\n尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78992805一，定义Unity协程(Coroutine)，不是卖机票的携程，是一种类似子线程的机制，可以用来实现一些延时处理的需求，c#中通过yield return语句配合可以中断执行，延时一定时间后从中断处继续执行。\n二，注意协程不是线程，协程不是线程，协程不是线程，协程还是在主线程里！！！\n三，语法脚本需要继承MonoBehaviour，提供了两个方法StartCoroutine(IEnumerator routine)或者StartCoroutine(string methodName)开启一个协程，以及对应的StopCoroutine(IEnumerator routine)或StopCoroutine(string methodName)关闭协程。推荐使用前者，因为传递方法名需要用到反射机制，影响性能。\n四，常见应用1）延时（别想歪）\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleClass : MonoBehaviour\n&#123;\n\tIEnumerator Start()\n\t&#123;\n\t\tDebug.Log(&quot;Start--&quot; + Time.time);\n\t\tyield return StartCoroutine(WaitAndLog);\n\t\tDebug.Log(&quot;End--&quot; + Time.time);\n\t&#125;\n\t\n\tIEnumerator WaitAndLog()\n\t&#123;\n\t\tyield return new WaitForSeconds(3);\n\t\tDebug.Log(&quot;Wait--&quot; + Time.time);\n\t&#125;\n&#125;\n\n2）分帧加载\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleClass : MonoBehaviour\n&#123;\n\tprivate int _num,_total;\n\tStart()\n\t&#123;\n\t\tStartCoroutine(LoadAssets);\n\t&#125;\n\t\n\tIEnumerator LoadAssets()\n\t&#123;\n\t\twhile(_num &lt; _total)\n\t\t&#123;\n\t\t\t_num++;\n\t\t\tDebug.Log(&quot;Load an Asset&quot;);\n\t\t\tyield return null;\n\t\t&#125;\n\t&#125;\n&#125;\n\n五，yieldyield语句用于暂停协程的执行，yield return 的值决定什么时候恢复协程的执行。yield return 返回一个IEnumerator对象，当该对象的MoveNext()返回false，即该对象的Current已迭代到最后一个元素时，才会执行yield return后的代码。\nyield语句的返回有如下类型：\nyield return null;&#x2F;&#x2F;下一帧再继续往下执行\nyield return new WaitForFixedUpdate();&#x2F;&#x2F;等到下一次调用FixedUpdate再往下执行\nyield return new WaitForSceonds(n);&#x2F;&#x2F;等待n秒再往下执行\nyield return StartCoroutine(Method);&#x2F;&#x2F;开启另一个协程，直到Method执行完毕再往下执行\nyield return new WaitForEndOfFrame();&#x2F;&#x2F;等到该帧结束再往下执行\nyield return WWW;&#x2F;&#x2F;等待资源加载完成再往下执行\nyield break;&#x2F;&#x2F;结束协程\n六，执行顺序协程是每帧lateUpdate前执行yield return之前的代码，lateUpdate后执行yield return之后的代码。\n不同yield return返回值的执行顺序，通过官方文档的一张流程图可以清晰地了解：\nhttp://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg  \n七，原理Unity的协程应该是一个扩展成支持嵌套的迭代器（IEnumator）。\n它将c# IEnumerator封装为Coroutine对象，它记录了该协程的上一级协程是谁，当这个协程执行完成，会继续执行上一级协程。\n当Unity Coroutine调用IEnumerator的MoveNext返回一个新Coroutine时，Unity设置新对象的上级Coroutine为当前Coroutine，同时将新Coroutine压入队列，通过此实现嵌套。\n然后Unity在主线程中定时检测当前每个等待的Coroutine，满足条件则执行。\n八，在Editor下使用Coroutine编辑器下因为没有运行Unity，也没有创建GameObject，因此也无法通过Monobehaviour的StartCoroutine创建协程。\n以下代码来自网上不知哪位大牛，根据Unity协程原理另外实现了个协程：\n1，EditorCoroutine协程类实现了IEnumerator接口，在MoveNext函数中实现了嵌套调用协程\npublic class EditorCoroutine : IEnumerator  \n    &#123;  \n        private Stack&lt;IEnumerator&gt; executionStack;  \n  \n        public EditorCoroutine(IEnumerator iterator)  \n        &#123;  \n            this.executionStack &#x3D; new Stack&lt;IEnumerator&gt;();  \n            this.executionStack.Push(iterator);  \n        &#125;  \n  \n        public bool MoveNext()  \n        &#123;  \n            IEnumerator i &#x3D; this.executionStack.Peek();  \n  \n            if (i.MoveNext())  \n            &#123;  \n                object result &#x3D; i.Current;  \n                if (result !&#x3D; null &amp;&amp; result is IEnumerator)  \n                &#123;  \n                    this.executionStack.Push((IEnumerator)result);  \n                &#125;  \n  \n                return true;  \n            &#125;  \n            else  \n            &#123;  \n                if (this.executionStack.Count &gt; 1)  \n                &#123;  \n                    this.executionStack.Pop();  \n                    return true;  \n                &#125;  \n            &#125;  \n  \n            return false;  \n        &#125;  \n  \n        public void Reset()  \n        &#123;  \n            throw new System.NotSupportedException(&quot;This Operation Is Not Supported.&quot;);  \n        &#125;  \n  \n        public object Current  \n        &#123;  \n            get &#123; return this.executionStack.Peek().Current; &#125;  \n        &#125;  \n  \n        public bool Find(IEnumerator iterator)  \n        &#123;  \n            return this.executionStack.Contains(iterator);  \n        &#125;  \n    &#125;  \n\n2，EditorCoroutineRunner类，类似MonoBehaviour，提供了StartEditorCoroutine方法创建一个协程\npublic static class EditorCoroutineRunner  \n&#123;      \n    private static List&lt;EditorCoroutine&gt; editorCoroutineList;  \n    private static List&lt;IEnumerator&gt; buffer;  \n  \n    public static IEnumerator StartEditorCoroutine(IEnumerator iterator)  \n    &#123;  \n        if (editorCoroutineList &#x3D;&#x3D; null)  \n        &#123;  \n            editorCoroutineList &#x3D; new List&lt;EditorCoroutine&gt;();  \n        &#125;  \n        if (buffer &#x3D;&#x3D; null)  \n        &#123;  \n            buffer &#x3D; new List&lt;IEnumerator&gt;();  \n        &#125;  \n        if (editorCoroutineList.Count &#x3D;&#x3D; 0)  \n        &#123;  \n            EditorApplication.update +&#x3D; Update;  \n        &#125;  \n  \n        buffer.Add(iterator);  \n      \n        return iterator;  \n    &#125;  \n  \n    private static bool Find(IEnumerator iterator)  \n    &#123;   \n        foreach (EditorCoroutine editorCoroutine in editorCoroutineList)  \n        &#123;  \n            if (editorCoroutine.Find(iterator))  \n            &#123;  \n                return true;  \n            &#125;  \n        &#125;  \n  \n        return false;  \n    &#125;  \n  \n    private static void Update()  \n    &#123;  \n        editorCoroutineList.RemoveAll  \n        (  \n            coroutine &#x3D;&gt; &#123; return coroutine.MoveNext() &#x3D;&#x3D; false; &#125;  \n        );  \n  \n\n        if (buffer.Count &gt; 0)  \n        &#123;  \n            foreach (IEnumerator iterator in buffer)  \n            &#123;  \n                if (!Find(iterator))  \n                &#123;  \n                    editorCoroutineList.Add(new EditorCoroutine(iterator));  \n                &#125;  \n            &#125;  \n  \n            buffer.Clear();  \n        &#125;  \n  \n        if (editorCoroutineList.Count &#x3D;&#x3D; 0)  \n        &#123;  \n            EditorApplication.update -&#x3D; Update;  \n        &#125;  \n    &#125;  \n&#125;  \n\n3，调用\nusing UnityEngine;\nusing System.Collections;\n\npublic class ExampleClass\n&#123;\n\tStart()\n\t&#123;\n\t\tEditorCoroutineRunner.StartEditorCoroutine(Routine);\n\t&#125;\n\t\n\tIEnumerator Routine()\n\t&#123;\n\t\tDebug.Log(&quot;Routine&quot;);\n\t\tyield return null;\n\t&#125;\n&#125;\n\n九，参考http://gad.qq.com/article/detail/10552  \nhttp://blog.csdn.net/langresser_king/article/details/44244369\n","slug":"Unity协程&在编辑器中使用协程","date":"2018-01-06T17:42:45.000Z","categories_index":"Unity","tags_index":"unity coroutine unity协程 use coroutine in uni 编辑器中使用协程","author_index":"GodwinTsai"},{"id":"0fcb6ec26ac7da2494cb667ad8d042c2","title":"ETC1+Alpha纹理压缩自动化脚本","content":"\n\n尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78798054  \n一，压缩方式\n我们在Unity中对于图集和纹理，常用的压缩方案按照质量从低到高可以分为：\n高压缩：Android:ETC1+Alpha, IOS:PVRTC4中压缩：RGBA16+Dithering无压缩：RGBA32  \n二，自动化脚本  \n有很多工具可以处理上述压缩方案，例如TexturePack。今天来总结下采用脚本自动将纹理生成ETC1+Alpha的压缩方案。\n采用的是Unity自带的一个压缩&#x2F;解压缩ETC格式的图像工具：etcpack.exe。在Unity 4.x中可以在Unity安装目录&#x2F;Editor&#x2F;Data&#x2F;Tools&#x2F;中找到，Unity5.x中就被移除了。更多参考： https://en.wikipedia.org/wiki/Ericsson_Texture_Compression  \n1，有了这个工具，我们并不知道怎么用。首先打开cmd，在cmd中运行这个exe。可以看到输出了使用方法和例子。   \n2，接着我们写个bat脚本来调用这个工具，保存为etc.bat文件  \n@echo etc tool\n@echo %1\n@echo %2\n@echo %3\n@echo %4\n@echo %5\n@echo %6\n@echo %7\n@echo %8\n@set pngPath&#x3D;%1\n@set outputPath&#x3D;%2\n@set pkmPath&#x3D;%3\n@set alphaPkmPath&#x3D;%4\n@set pkmName&#x3D;%5\n@set alphaPkmName&#x3D;%6\n@set etcToolPath&#x3D;%7\n@set speed&#x3D;%8\n\ncd &#x2F;d %etcToolPath%\n@echo Convert PNG to PKM without alpha channel and solo alpha PKM files\netcpack %pngPath% %outputPath% -c etc1 -s %speed% -as -progress\n@echo Convert PKM files to PNG files\netcpack %pkmPath% %outputPath% -ext PNG\netcpack %alphaPkmPath% %outputPath% -ext PNG\n@echo Remove PKM files\ncd &#x2F;d %outputPath%\ndel %pkmName% &#x2F;f\ndel %alphaPkmName% &#x2F;f\n@echo DONE\n#pause\n\n3，我们在Unity中调用这个bat脚本，主要步骤有：\nA，C#创建cmd进程的方法\npublic static void ExecuteProcess(string filePath, string command, string workPath &#x3D; &quot;&quot;, int seconds &#x3D; 0)\n        &#123;\n            if (string.IsNullOrEmpty(filePath))\n            &#123;\n                return;\n            &#125;\n            Process process &#x3D; new Process();&#x2F;&#x2F;创建进程对象\n            process.StartInfo.WorkingDirectory &#x3D; workPath;\n            process.StartInfo.FileName &#x3D; filePath;\n            process.StartInfo.Arguments &#x3D; command;\n            process.StartInfo.CreateNoWindow &#x3D; true;\n            process.StartInfo.RedirectStandardOutput &#x3D; false;&#x2F;&#x2F;不重定向输出\n            try\n            &#123;\n                if (process.Start())\n                &#123;\n                    if (seconds &#x3D;&#x3D; 0)\n                    &#123;\n                        process.WaitForExit(); &#x2F;&#x2F;无限等待进程结束\n                    &#125;\n                    else\n                    &#123;\n                        process.WaitForExit(seconds); &#x2F;&#x2F;等待毫秒\n                    &#125;\n                &#125;\n            &#125;\n            catch (Exception e)\n            &#123;\n                Debug.LogError(e.Message);\n            &#125;\n            finally\n            &#123;\n                process.Close();\n            &#125;\n        &#125;\n\nB，通过A中方法传入参数执行etc.bat，方法参数是图片asset\npublic static void CompressPngToEtc(UnityEngine.Object asset)\n        &#123;\n            string pngPath &#x3D; string.Concat(Application.dataPath.Replace(&quot;&#x2F;Assets&quot;, &quot;&#x2F;&quot;),\n                AssetDatabase.GetAssetPath(asset));\n            string etcToolPath &#x3D; string.Concat(Application.dataPath.Replace(&quot;&#x2F;Assets&quot;, &quot;&quot;), &quot;&#x2F;tools&#x2F;etc_tool&#x2F;&quot;);\n            string etcBatPath &#x3D; etcToolPath + &quot;&#x2F;etc.bat&quot;;\n\n            string pngName &#x3D; asset.name + &quot;png&quot;;\n            string pngFolderPath &#x3D; Path.GetDirectoryName(pngPath);\n\n            string outputPath &#x3D; pngFolderPath + &quot;&#x2F;etc&quot;;\n\n            string pkmName &#x3D; pngName.Replace(&quot;.png&quot;, &quot;.pkm&quot;);\n            string pkmPath &#x3D; outputPath + &quot;&#x2F;&quot; + pkmName;\n\n            string alphaPkmName &#x3D; pngName.Replace(&quot;.png&quot;, &quot;_alpha.pkm&quot;);\n            string alphaPkmPath &#x3D; outputPath + &quot;&#x2F;&quot; + alphaPkmName;\n\n            string speed &#x3D; &quot;fast&quot;;\n\n            string args &#x3D; string.Format(&quot;\\&quot;&#123;0&#125;\\&quot; \\&quot;&#123;1&#125;\\&quot; \\&quot;&#123;2&#125;\\&quot; \\&quot;&#123;3&#125;\\&quot; &#123;4&#125; &#123;5&#125; \\&quot;&#123;6&#125;\\&quot; &#123;7&#125;&quot;, pngPath, outputPath,\n                pkmPath, alphaPkmPath, pkmName, alphaPkmName, etcToolPath, speed);\n            ExecuteProcess(etcBatPath, args);\n        &#125;\n\nC，增加编辑器菜单选择要处理的图片\n[MenuItem(&quot;Assets&#x2F;Compress png 2 etc&quot;, false, 10001)]\npublic static void CreateEtc()\n&#123;\n    string path;\n    UnityEngine.Object matAsset;\n    UnityEngine.Object[] selectedAssets &#x3D; Selection.GetFiltered(typeof(Texture2D), SelectionMode.DeepAssets);\n    foreach (Object asset in selectedAssets)\n    &#123;\n        path &#x3D; AssetDatabase.GetAssetPath(asset);\n        matAsset &#x3D; AssetDatabase.LoadAssetAtPath(path.Replace(&quot;.png&quot;, &quot;.mat&quot;), typeof (Material)) as Material;\n        if (matAsset !&#x3D; null)\n        &#123;\n            CompressPngToEtc(asset);\n        &#125;\n    &#125;\n&#125;\n\n\n[MenuItem(&quot;Assets&#x2F;Compress png 2 etc&quot;, true, 10001)]\npublic static bool CreateEtcEnabled()\n&#123;\n    for (int i &#x3D; 0; i &lt; Selection.objects.Length; i++)\n    &#123;\n        var obj &#x3D; Selection.objects[i];\n        var filePath &#x3D; AssetDatabase.GetAssetPath(obj);\n        if (filePath.EndsWith(&quot;.png&quot;, System.StringComparison.CurrentCultureIgnoreCase) ||\n            filePath.EndsWith(&quot;.jpg&quot;, System.StringComparison.CurrentCultureIgnoreCase))\n        &#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nD，生成rgb图片以及alpha图片后设置图片格式  \npublic static void SetTextureType(string path, TextureImporterFormat format, FilterMode mode &#x3D; FilterMode.Bilinear)\n        &#123;\n            TextureImporter importer &#x3D; AssetImporter.GetAtPath(path) as TextureImporter;\n            if (importer !&#x3D; null)\n            &#123;\n                importer.textureType &#x3D; TextureImporterType.Sprite;\n                importer.textureFormat &#x3D; format;\n                importer.filterMode &#x3D; mode;\n                importer.mipmapEnabled &#x3D; false;\n                \n                TextureImporterSettings tis &#x3D; new TextureImporterSettings();\n                importer.ReadTextureSettings(tis);\n                importer.SetTextureSettings(tis);\n                AssetDatabase.ImportAsset(path);\n            &#125;\n        &#125;\n\npublic static void SetTextureTypeCompressed(object pngAsset)\n        &#123;\n\t    Texture2D mainTexture &#x3D; AssetDatabase.LoadAssetAtPath(pngPath.Replace(pngAsset.name, &quot;etc&#x2F;&quot; + pngAsset.name), typeof (Texture2D)) as Texture2D;\n            Texture2D alphaTexture &#x3D; AssetDatabase.LoadAssetAtPath(pngPath.Replace(pngAsset.name, &quot;etc&#x2F;&quot; + pngAsset.name + &quot;_alpha&quot;), typeof (Texture2D)) as Texture2D;\n            string mainPath &#x3D; AssetDatabase.GetAssetPath(mainTexture);\n            string alphaPath &#x3D; AssetDatabase.GetAssetPath(alphaTexture);\n            SetTextureType(mainPath, TextureImporterFormat.AutomaticCompressed);\n            SetTextureType(alphaPath, TextureImporterFormat.AutomaticCompressed);\n        &#125;\n\nE，设置材质球Shader为UIETC，并引用两张生成的图片\npublic static void SetMaterialEtcShader(UnityEngine.Object asset)\n        &#123;\n            string path;\n            Material mat;\n            Texture2D mainTexture;\n            Texture2D alphaTexture;\n\n            path &#x3D; AssetDatabase.GetAssetPath(asset);\n            mat &#x3D; asset as Material;\n            if (mat &#x3D;&#x3D; null)\n            &#123;\n                return;\n            &#125;\n            mat.shader &#x3D; Shader.Find(&quot;Mogo&#x2F;UIETC&quot;);\n            mainTexture &#x3D; AssetDatabase.LoadAssetAtPath(path.Replace(asset.name + &quot;.mat&quot;, &quot;etc&#x2F;&quot; + asset.name + &quot;.png&quot;), typeof(Texture2D)) as Texture2D;\n            mat.mainTexture &#x3D; mainTexture;\n            alphaTexture &#x3D; AssetDatabase.LoadAssetAtPath(path.Replace(asset.name + &quot;.mat&quot;, &quot;etc&#x2F;&quot; + asset.name + &quot;_alpha.png&quot;), typeof(Texture2D)) as Texture2D;\n            mat.SetTexture(&quot;_AlphaTex&quot;, alphaTexture);\n        &#125;\n\n4,运行效果\n","slug":"ETC1+Alpha纹理压缩自动化脚本","date":"2017-12-13T15:28:47.000Z","categories_index":"Ngui","tags_index":"ETC1 Alpha","author_index":"GodwinTsai"},{"id":"77e0ad570f11e18afc3feb02810d2091","title":"Unity&NGUI渲染层级","content":"\n\n尊重原创，转载请在文首注明出处：http://blog.csdn.net/cai612781/article/details/78477944  \n项目中经常遇到层级的显示问题，来总结下。\n一，Unity按优先级从高到低排列：\n1，Camera.depthdepth小的先渲染。\n  \n2，Renderer.sortingLayerIDsortingLayerID为基类Renderer的属性，sortingLayerID小的先渲染。\n3，Renderer.sortingOrder\nsortingOrder同为基类Renderer的属性，sortingOrder小的先渲染。\nsortingLayerID和sortingOrder虽然是基类Renderer的属性，但只适用于Unity2d的排序，因此我们在面板中可以看到只有显示图片的SpriteRenderer和显示粒子的\nParticleSystemRenderer有这两个属性。\n  \n4，Material.renderQueue该属性对应的是Shader的renderQueue，renderQueue的范围必须是[0,5000]，数值小的先渲染。Shader中使用SubShader的Queue标签来设定模型属于哪个渲染队列。\nUnity内置了几个渲染队列的枚举：\npublic enum RenderQueue\n&#123;\n        Background &#x3D; 1000,&#x2F;&#x2F;最先渲染，通常用来绘制背景\n        Geometry &#x3D; 2000,&#x2F;&#x2F;不透明物体的渲染\n        AlphaTest &#x3D; 2450, &#x2F;&#x2F; 需要透明度测试的物体，在不透明物体渲染后再渲染会更高效\n        GeometryLast &#x3D; 2500, &#x2F;&#x2F; 分界线，[0,2500]为不透明物体，[2501,5000]为半透明物体\n        Transparent &#x3D; 3000,&#x2F;&#x2F;半透明物体的渲染，任何使用了透明度混合（例如关闭了深度写入）的物体都用得用该队列\n        Overlay &#x3D; 4000,&#x2F;&#x2F;用于叠加效果\n&#125;\n\n上述排序是在Shader关闭了深度写入（ZWrite Off）的情况下，当开启了深度写入时，物体的空间位置（transform.position.z）会影响层级，z值小的在前面。\n另外，Unity菜单Edit-&gt;Project Settings-&gt;Tags中的Layers,只是一个逻辑的分层，用于Camera的Culling Mask来设置相机渲染哪个Layer的物体，辅助Camera.depth来管理层级。\n二，NGUI按优先级从高到低排列：  \n1，UIPanel.sortingOrder通过源码可以看到UIPanel.sortingOrder更改的就是上文中Renderer.sortingOrder。\n2，UIPanel.depthdepth小的先渲染\n3，UIWidget.depthdepth小的先渲染，NGUI根据UIWidget.depth的排序合并drawcall（因此尽量将相同材质的图集在depth上排在一起可以减少UI上的drawcall）。\nUIPanel面板还有个Render Q属性，用来设置该面板的renderQueue的起始值，所有面板总的起始值默认为3000。该属性有三种选项，分别是\nAutomatic，StartAt，Explicit，后两者可自定义renderQueue的起始值。\n  \n当Render Q默认为Automatic时，根据UIPanel.depth的排序对drawcall的材质的renderqueue进行排序。\n当Render Q默认为StartAt或Explicit时，UIPanel.depth则不起作用，根据自定义的值对drawcall的材质的renderqueue进行排序。\nNGUI所用的shader都是关闭了深度写入的，因此z值不影响层级。所以NGUI本质还是通过Unity的sortingOrder和renderQueue来管理层级。\n三，NGUI与模型或特效的夹层问题我们在处理模型或特效显示在两个UI之间的层级显示问题，有两种方式：\n1，利用Camera.depth属性，将界面A，模型或特效，界面B分别放在三个Layer，用三个depth递增的相机来渲染。（该方式不推荐，因为一个界面上可能会打开新的界面，以及两个界面的相对层次不是固定的，这样会导致相机不断增加，层次管理混乱）\n2，利用renderQueue属性，给两个UIPanel之间留下一定范围的renderQueue数值，将模型或特效的renderQueue设置在这个范围内。（推荐该方式）\n代码如下：\n第一步，新增renderQueue控制脚本：RenderQueueContro.cs\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class RenderQueueControl : MonoBehaviour\n&#123;\n\tprivate UIPanel _panel;\n\t\n\tprivate int _rq;\n\tprivate List&lt;Material&gt; _materialList &#x3D; new List&lt;Material&gt;();\n\tprivate int i, len;\n\t\n\tvoid Start()\n\t&#123;\n\t&#125;\n\t\n\tpublic void Init()\n\t&#123;\n\t\t_panel &#x3D; NGUITools.FindInParents&lt;UIPanel&gt;(gameObject);\n\t\tUIPanel.AddModelRQ(this);\n\t\tInitMaterials();\n\t&#125;\n\t\n\tprivate void InitMaterials()\n\t&#123;\n\t\t_materialList.Clear();\n\t\tRenderer[] ren &#x3D; GetComponentsInChildren&lt;Renderer&gt;();\n\t\tif(ren !&#x3D; null)\n\t\t&#123;\n\t\t\tfor(i &#x3D; 0, len &#x3D; ren.Length; i &lt; len; i++)\n\t\t\t&#123;\n\t\t\t\t_materialList.AddRange(ren[i].materials);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\tpublic void UpdateRQ()\n\t&#123;\n\t\tif(_panel !&#x3D; null &amp;&amp; _panel.drawCalls.Count &gt; 0)\n\t\t&#123;\n\t\t\t_rq &#x3D; _panel.drawCalls[_panel.drawCalls.Count - 1].renderQueue + 1;\n\t\t\tfor(i &#x3D; 0, len &#x3D; _materialList; i &lt; len; i++)\n\t\t\t&#123;\n\t\t\t\tif(_materialList[i].renderQueue !&#x3D; _rq)\n\t\t\t\t&#123;\n\t\t\t\t\t_materialList[i].renderQueue &#x3D; _rq;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\tvoid OnDestroy()\n\t&#123;\n\t\t_materialList.Clear();\n\t\tUIPanel.RemoveRQ(this);\n\t&#125;\n&#125;\n\n第二步，给两个UIPanel之间留下一定范围的renderQueue数值，并在UIPanel更新时修改模型的renderQueue。我们修改UIPanel.LateUpdate（注释为修改处）。\nvoid LateUpdate()\n&#123;\n\tif(mUpdateFrame !&#x3D; Time.frameCount)\n\t&#123;\n\t\tmUpdateFrame &#x3D; Time.frameCount;\n\t\t\n\t\tfor(int i &#x3D; 0, imax &#x3D; list.Count; i &lt; imax; ++i)\n\t\t&#123;\n\t\t\tlist[i].UpdateSelf();\n\t\t&#125;\n\t\t\n\t\tint rq &#x3D; 3000;\n\t\tfor(int i &#x3D; 0, imax &#x3D; list.Count; i &lt; imax; ++i)\n\t\t&#123;\n\t\t\tUIPanel p &#x3D; list[i];\n\t\t\tif(p.renderQueue &#x3D;&#x3D; RenderQueue.Automatic)\n\t\t\t&#123;\n\t\t\t\tp.startingRenderQueue &#x3D; rq;\n\t\t\t\tp.UpdateDrawCalls();\n\t\t\t\trq +&#x3D; p.drawCalls.Count * 2;&#x2F;&#x2F;加上*2\n\t\t\t&#125;\n\t\t\telse if(p.renderQueue &#x3D;&#x3D; RenderQueue.StartAt)\n\t\t\t&#123;\n\t\t\t\tp.UpdateDrawCalls();\n\t\t\t\tif(p.drawCalls.Count !&#x3D; 0)\n\t\t\t\t&#123;\n\t\t\t\t\trq &#x3D; Mathf.Max(rq, p.startingRenderQueue + p.drawCalls.Count * 2);&#x2F;&#x2F;加上*2\n\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tp.UpdateDrawCalls();\n\t\t\t\tif(p.drawCalls.Count !&#x3D; 0)\n\t\t\t\t&#123;\n\t\t\t\t\trq &#x3D; Mathf.Max(rq, p.startingRenderQueue + 1 * 2);&#x2F;&#x2F;加上*2\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tUpdateModelRQ();&#x2F;&#x2F;加上刷新rq\n\t&#125;\n&#125;\n\nprivate static List&lt;RenderQueueControl&gt; _modelRQList &#x3D; new List&lt;RenderQueueControl&gt;();\n\npublic static void AddModelRQ(RenderQueueControl control)\n&#123;\n\tif(!_modelRQList.Contains(control))\n\t&#123;\n\t\t_modelRQList.Add(control);\n\t&#125;\n&#125;\n\npublic static void RemoveModelRQ(RenderQueueControl control)\n&#123;\n\t_modelRQList.Remove(control);\n&#125;\n\nprivate void UpdateModelRQ()\n&#123;\n\tfor(int i &#x3D; 0, len &#x3D; _modelRQList.Count; i &lt; len; i++)\n\t&#123;\n\t\tif(_modelRQList[i] &#x3D;&#x3D; null)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\t_modelRQList[i].UpdateRQ();\n\t&#125;\n&#125;\n\n第三步，加载模型或特效后的调用\npublic static void AddModelParent(GameObject modelGo, Transform parentTran)\n&#123;\n\tif(modelGo &#x3D;&#x3D; null || parentTran &#x3D;&#x3D; null || parentTran.gameObject &#x3D;&#x3D; null)\n\t&#123;\n\t\treturn;\n\t&#125;\n\tmodelGo.transform.parent &#x3D; parentTran;\n\t\n\tint layerUi &#x3D; parentTran.gameObject.layer;\n\tSetLayerRecursively(parentTran.gameObject, layerUi);\n\t\n\tRenderQueueControl rqControl &#x3D; modelGo.AddMissingComponent&lt;RenderQueueControl&gt;();\n\trqControl.Init();\n&#125;\n\npublic static void SetLayerRecursively(GameObject parent, int layer)\n&#123;\n\tif(parent &#x3D;&#x3D; null)\n\t&#123;\n\t\treturn;\n\t&#125;\n\tparent.layer &#x3D; layer;\n\tforeach(Transform child in parent.transform)\n\t&#123;\n\t\tif(child &#x3D;&#x3D; null)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\tSetLayerRecursively(child.gameObject, layer);\n\t&#125;\n&#125;\n\n效果图\n","slug":"Unity&NGUI渲染层级","date":"2017-11-08T06:00:02.000Z","categories_index":"Unity","tags_index":"Unity渲染层级 ngui渲染层级","author_index":"GodwinTsai"}]